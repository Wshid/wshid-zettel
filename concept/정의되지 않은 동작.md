---
date: 2024-05-01
datetime: 2024-05-01 09:55:06
book: 러스트_동시성_프로그래밍
page:
  - "33"
tags: 
references: 
aliases:
  - Undefined behavior
---
- C, C++, Rust 같은 언어는 **정의되지 않은 동작**(undefined behavior)를 피하기 위한 규칙을 가지고 있음
	- e.g. Rust, 객체에 한 개 이상의 가변 레퍼런스를 만들 수 없음
- Rust에서 이런 규칙을 무시하려면 `unsafe` 키워드 사용
	- 코드가 잘못되었거나, 사용하기 위험하다 -> X
	- 컴파일러가 코드가 안전한지 검사하지 X
- 컴파일러 규칙을 위반하는 코드 -> unsound(불건전)하다고 함
- 컴파일러는 코드를 들여다보지 않고도, 규칙은 항상 지켜진다고 생각함
	- 규칙이 깨진다면, 이 상황이 **정의되지 않은 동작**이 되며, 무조건 막아야 함
- 컴파일러가 이런 규칙을 지키지 않으면, 코드의 여러부분에서 잘못된 결과 발생

#### get_unchecked
```rust
let a = [123, 456, 789];
let b = unsafe { a.get_unchecked(index) };
```
- `get_unchecked` 메서드
	- 주어진 인덱스를 사용하여, 슬라이스의 원소 1개를 가져옴
	- `a[index]`를 사용하면, 컴파일러가 인덱스 범위를 벗어났는지를 확인하지만,
	- `get_unchecked` 메서드 사용시, 컴파일러가 확인하지 X
- a의 길이가 3이므로, compiler는 index가 3보다 작은 값이라고 가정함
	- 단, 위 상황에서는 index에 따라 컴파일러의 가정이 맞을수도 틀릴수도 있음
- `index`가 3 이상이라면, 이 가정이 깨짐
	- 슬라이스의 메모리 범위보다 1바이트 뒤를 읽으며, 아무 값이나 읽음
	- 프로그램의 예상치 못한 종료
	- 의도하지 않는 결과 수행
- 또한, 정의되지 않은 동작은 그 이전의 코드에 문제를 일으킬 수도 있음

#### 이전의 코드의 문제를 발생시키는 경우
```rust
match index {
	0 => x(),
	1 => y(),
	_ => z(index),
}

let a = [123, 456, 789];
let b = unsafe { a.get_unchecked(index) };
```
- `unsafe`코드 때문에, compiler는 index가 0,1,2 중에 하나라고 생각
	- match에서 마지막 경우는 index가 2가 된다고 생각해서, match의 결과는 z(2)가 됨
- 컴파일러가 match문을 최적화 할때 사용하는 방법은 `z`를 최적화 할때도 사용 가능
	- z(index)가 항상 z(2)로 사용된다면, 필요 없는 코드를 컴파일 과정에서 버릴 수 있음
- 만약 `index=3`으로 수행하게 되면, match 구문에서 `z(3)`을 수행하려고 할 것
	- 마지막 `unsafe`줄에 도달하기 전에 예상치 못한 문제 발생
- 정의되지 않은 동작은 예상치 못한 방법으로
	- 프로그램 진행 방향 또는 반대 방향으로 전파 가능
- `unsafe`함수를 호출시,
	- 함수의 문서를 주의 깊게 읽고,
	- 정의되지 않은 동작을 피하기 위해 지켜야할 안전 요구 사항(safety requirement)를 이해하는 것이 중요