---
date: 2025-10-14
datetime: 2025-10-14 22:05:48
book: 무엇이_1등_팀을_만드는가
page:
  - "77"
tags:
references:
aliases:
---
- [[효과성]]
- 팀 성과와 관련한 효율성(Effectiveness) 및 생산성(Productivity)의 의미란?
	- 서로 연결되어 있지만 각기 다른 의미를 가짐
- 효율적인 소프트웨어 엔지니어링 팀이 되려면
	- 프로세스 준수, 코드 깔끔하게, 문제 해결, 마감일 준수, 코드 대량 생산
- 생산성이 높은 소프트웨어 엔지니어링 팀이 되려면
	- 코드 작성, 테스트, 수정 및 릴리즈 작업을 신속하게 완료
- 효과적인 팀이 되려면
	- 배포된 코드가 사용자의 어려움을 해결하고 비즈니스에 긍정적인 영향을 미칠 수 있어야 함
- 간단 정리
	- **효율성**: 일을 올바르게 수행하는 것
	- **효과성**: 올바른 일을 하는 것
	- **생산성**: 투자 대비 산출량의 척도
- 상기 어느 것이든 팀의 성과를 측정하는데 사용할 수 있으나, 정확히 각 개념의 의미를 이해하는 것이 중요
	- 각 개념의 의미를 이해하는 것이 중요
	- 그리고 각 요소에 영향을 미치는 요인, 지식 노동의 영향을 측정하는 방법
	- 결과물 보다는 성과에 집중하는 것의 중요성, 효과성과 효율성 사이의 적절한 균형을 맞추도록 팀 문화를 바꾸는 방법

# 2.1. 효율성, 효과성, 생산성의 차이점

## 2.1.1. 목표
- 효율성, 효과성, 생산성에 대한 자세한 정의부터 각 용어가 의미하는 바와 서로의 목표가 어떻게 다른지 확인

### 효율성
- 낭비를 최소화하고 결과물을 극대화 하도록 **일을 올바르게 하는 것**
- 소프트웨어 엔지니어링 팀은 반복적 방법론을 채택하고
	- 지속적인 통합, 배포 파이프라인 구현, 코드 편집기, 디버거, 성능 프로파일러와 같은 도구를 사용하여 효율성 개선
- 이러한 방법들을 사용하여 효율성을 개선하는 소프트웨어 엔지니어링 팀은
	- 주어진 자원 하에서 완전하게 개발된 기능의 수 극대화 가능
- **팀의 효율성을 측정하는 좋은 척도**
	- 단위 시간당 얼마나 많은 기능이 완전히 개발되고 테스트되었는가를 측정
	- e.g. 이번 주에 세 가지 기능을 출시했는데 각각 3일이 걸렸음

### 효과성
- **올바른 일**을 하고 적절한 성과를 내는 것
	- 적절한 성과를 내는 것뿐만 아니라 효과성을 위한 올바른 방향으로 나아가야 된다는 의미
- 적절한 성과 -> 조직과 고객에게 가치 제공 -> 고객의 요구사항에 초점을 맞추는 것
- 조직의 목표 = 팀의 목표, 명확한 전략 정의, 성과 집중
- 소프트웨어 엔지니어링 팀은 조직의 비전에 부합하는 기능과 기획의 우선순위를 정하고
	- 여러 지표를 활용하여 해당 기능의 영향력을 측정하며
	- 고객과 이해관계자의 피드백을 구하는 방식으로 업무 효과 개선 가능
- e.g. 사용자 채택률 및 고객 만족도 점수와 같은 주요 지표 추적을 통해 소프트웨어 효과성 측정 가능

### 생산성
- 효율성의 하위 개념, **투입 대비 산출량**
- 팀이 목표를 빠르게 달성하기 위해 얼마나 빠른 속도로 작업을 수행하는가
- 소프트웨어 엔지니어링 팀은 처리량, 속토, 코드 산출량 증가 -> 생산성 향상
- 단, 생산성에 대한 기존 정의는 결과물의 품질과 영향력을 고려하지 않음
- 생산성은 종종 기계와 자본의 효율성 측정시 사용
- 하지만 인간의 지식 노동을 정확히 측정 불가


|      | 효율성          | 효과성       | 생산성        |
| ---- | ------------ | --------- | ---------- |
| 목표   | 일을 올바르게 수행하기 | 올바른 일을 하기 | 투입 대비 결과물  |
| 측정방법 | 시간           | 고객만족도     | 코드 줄 수     |
|      | 리소스 활용도      | 비즈니스 가치   | 기능 점수 부여   |
|      | 품질           | 사용자 채택률   | 스토리 포인트 부여 |

효율성, 효과성, 생산성을 달성하기 위해, 엔지니어링 팀은 전반적으로 각기 다른 목표 설정 필요
- 이러한 개념들 각각은 서로 다른 의미를 가질 수 있으나 상호 베타적이지는 않음

#### 예시: Cloudoids
- 가상조직, 주력 소프트웨어를 마이크로 서비스, K8s로 이전하는 작업 진행
	- 비즈니스에 대한 중요한 작업을 하면서 새로운 기술을 학습할 수 있다는 기회
	- 버그 없는 코드 완성, 마감일을 잘 만족시켰지만 성능 개선, 사용 편의성 향상이 없었다면
		- 지표를 통해 그들이 영향력 없는 기술 왕국 구축 확인
	- 기술 측면의 확장성 개선으로 빌드를 더 빠르게 배포할 수 있었겠으나
		- 사용자에게 도움이 되는 기술적 고려사항을 활용하지 못함
	- 사용자 관점에서 제품은 거의 그대로
		- **어떻게**에만 집중하고 **왜**에서는 소홀한 사례
- 위를 계기로 클라우도이드 팀은 올바른 성과에 집중하는 방향으로 전환
	- 팀원들의 아키텍처 변경 -> 어떤 이점이 있는지 알아보기 위해 과정을 회고
		- 점점 더 효율적이고 직관적으로 제품 사용이 가능하도록 디자인
	- 그리고 마침내 팀이 올바른 성과를 달성하기 위해 올바른 방식으로 기술 사용, 지표를 통해 확인
	- 이 팀은 **효율성**이란 단순히 빠른 속도, 화려한 기술만이 아니라는 사실을 깨달음
	- 즉, 기술적 고려사항을 목적에 맞게 잘 엮어내는 것 또한 효율성에 매우 중요한 영향을 준다는 것을 알게 됨
- 위 사례는 특정 상황에서 효율성과 생산성에 대한 적절한 정의, 지표 개발에 집중한다면
	- 팀의 전반적인 효율성을 극대화 할 수 있다는 교훈을 줌


## 2.1.2. 측정 방법
- 효율성, 효과성, 생산성은 모두 실적을 반영하나, 측정시 각각 고려해야 하는 요소가 다름
	- 생산성, 효율성: 모두 특정 활동의 결과물에 따라 다름
	- 단, 생산성은 가공되지 않은 측정치
	- 효율성은 정제된 측정치: 성과에 따라 달라짐
- 효과성 또한 성과에 따라 달라짐
	- 물론 결과물의 성과의 차이는 상이함

### 생산성
- 투자 대비 결과물 측정
- 코드 줄 수(Lines of Code, LOC)
	- 개발자가 작성한 코드 줄 수를 세는 방법
	- 코드를 더 많이 작성할수록 더 많은 성과 달성
- 기능 점수(Function Points, FP)
	- 소프트웨어가 제공하는 기능 바탕으로 측정
	- 소프트웨어의 복잡성과 제공하는 기능의 수 고려
- 스토리 포인트(Story Point)
	- 애자일 소프트웨어 개발에서 사용자의 스토리의 복잡성을 기준으로 측정
	- 사용자 스토리 각각의 복잡성과 요구되는 노력을 기준으로 할당
- 데브옵스 지표
	- 리드 타임(lead time), 배포 빈도, 평균 복구 시간, 변경 실패율과 같은 데브옵스 지표
	- 소프프트웨어 개발 프로세스 속도에 중점
- 생산적인 소프트웨어 엔지니어링 방식은
	- 팀이 구현하는 코드의 양 측면에서 더 많은 결과물을 만들 수 있음
	- 사용되는 지표에 따라 이는 제공된 코드의 줄 수 또는 기능 점수의 양이 더 많다는 것
	- 하지만 생산성에만 초점을 맞추면 문제

### 효율성
- 시간
	- 작업이 더 빨리 완료될수록 프로세스 효율성 증가
- 리소스 활용
	- 효율적인 팀은 시간, 비용, 인력 등의 자원 더 잘 활용
- 버그 수정률
	- 버그를 더 빨리 발견하고 수정할수록 효율적인 팀
- 결함 밀도
	- 코드 한 줄당 발견된 코드 결함의 수
	- 결함 밀도가 낮을수록 효율성이 높음
- 품질
	- 효율적인 팀은 고품질의 제품 생산
- 효율적인 소프트웨어 엔지니어링 방식은
	- 시간이나 비용과 같은 자원의 낭비를 줄여줌
	- 효율적인 팀은 자원 사용을 최적화 하여 생산성을 높이고 원하는 결과물을 만들어 냄

### 효과성
- 개발 활동의 궁극적인 성과
- 고객 만족도
	- 소프트웨어 제품이 사용자의 요구와 기대를 충족하는 정도
- 비즈니스 가치
	- 조직의 전반적인 목표와 목적에 소프트웨어 제품이 얼마나 기여하는지 측정
- 사용자 채택률
	- 소프트웨어 제품이 목표로 하는 사용자들에 의해 실제로 얼마나 사용되고 있는지
- 투자자본수익률(Return on Investment, ROI)
	- 소프트웨어 개발에 소요된 총비용 대비 얻은 순이익
- 시장 출시 속도
	- 소프트웨어 제품이 개발되어 시장에 출시되는 속도
- 효과적인 소프트웨어 엔지니어링 방식은
	- 고객 만족도, 비즈니스 가치, 사용자 채택률 및 ROI를 높힘
	- 또한 출시 기간이 단축되면 제품의 다치도 높아지므로 더욱 효과적

### 예시: 음식 배달 어플리케이션의 MVP
- MVP(Minimum Visible Products): 최소 기능 제품

#### 생산성이 높은 팀?
- 가정
	- A팀: 10명의 엔지니어, 30일만에 app MVP 제공
	- B팀: 8명의 엔지니어, 40일만에 비슷한 수준의 기능 제공
- 답
	- A팀. 주어진 시간동안 더 많은 결과물 구현 
	- 제공된 기능은 비슷하기 때문

#### 효율적인 팀?
- 가정
	- A팀: 사용성과 관련된 5가지 주요 이슈 발생 -> 5일의 추가 작업
	- B팀: 사용성과 관련된 3가지 주요 이슈 발생 -> 2일의 추가 작업
- 답
	- B팀. 더 높은 품질의 결과물을 생성하고 더 작은 자원(시간, 인력)을 사용하여 비용 절감
	- 만약 모든 엔지니어가 문제 해결에 참여했다면, A팀은 400시간 추가 근무, B팀은 128시간 추가 근무

#### 효과적인 팀?
- 가정
	- A팀: 출시 후 첫 달, 10k 다운로드, 동일한 고객으로부터 6k 재주문
	- B팀: 출시 후 첫달, 10k 다운로드, 2k 재주문
- 답
	- A팀, 사용자들이 더 많이 사용
	- 비즈니스 목표 달성 가능성이 높음

### 지표간 관계
- 지표 중 일부는 서로 미묘하게 연결되어 있음
- e.g. 결과물을 효율적으로 생성한다는 것은
	- 본질적으로 결과물을 생산적으로 생성 해야 한다는 것을 의미
- e.g. 시간을 효율적으로 사용하고 결함 밀도를 낮추면
	- 시장 출시기간 단축 및 고객 만족도가 높음
- 즉, 효율성 지표의 최적화를 통해 효과 극대화가 가능

## 2.1.3. 영향 요인
- 팀 규모, 다양성 및 기타 다양한 요인 또한 소프트웨어 엔지니어링 팀의 효율성, 효과성, 생산성 측정에 영향을 미침

### 팀 규모
- 소프트웨어 엔지니어링 팀의 규모는 업무 능력에 영향
- 규모가 큰 팀은 작업을 더 빨리 완료할 수 있으나, 의사소통 의견 조율 및 의사결정을 관리하기 위해 추가적인 노력이 필요
- 소규모 팀은 작업 속도가 느릴 수 있지만 협업이 더 원활하고 효율적으로 이루어질 수 있음
- **스크럼과 같은 애자일 방법론**은 팀이 업무량을 최적으로 관리하는 동시에
	- 의사소통 병목 현상을 해결하는데 도움
### 다양성
- 소프트웨어 엔지니어링 팀에 다양한 기술이 있으면 팀의 효과성과 생산성이 향상
- 다양한 배경과 전문 지식을 가진 팀원은 여러 각도에서 문제에 접근하고 보다 창의적인 솔루션 개발 가능
- 그러나 지나친 다양성은 의사소통을 어렵게 하거나 오해 유발
- 특히 팀원들이 서로 다른 아이디어가 아닌 다른 가치를 가지고 논의에 임할 때 더욱 문제가 됨
- **다양한 인력의 장점을 최대한 활용하려면 팀과 조직의 포용성을 강화하는 것이 필요**

### 역할 명확성
- 모든 팀원은 팀 내에서 자신의 역할과 책임을 명확히 이해해야 함
- 모든 사람이 자신의 업무가 무엇인지, 팀 내에서 자신의 역할이 무엇인지 이해하면
	- 불필요한 혼선, 중복 작업을 줄여 효율성, 생산성 향상이 가능
- 업무의 소유권이 모호하면 팀원 간의 갈등으로 이어져 시간과 노력 낭비
	- 명확성이 확보되면 팀원 간의 집중력 향상 가능

### 의사소통
- 원활한 의사소통 -> 사람들이 더 많이 질문하고 더 많이 의논하는 것을 의미
- 원활한 의사소통은 오인, 오해를 줄여 효율성 향상
	- 협업과 아이디어 공유를 촉진, 효과성 향상 가능

### 업무 환경
- 팀의 효율성, 효과성, 생산성에 큰 영향을 미침
- 편안하고 시설이 잘 갖춰진 업무 공간은 집중력, 창의력 향상 가능
- 시끄럽고 어수선한 환경 -> 주의 산만, 스트레스 유발
- 많은 소프트웨어 회사가 엔지니어간 협업 촉진을 위해 오픈 오피스 환경으로 전환
- 하지만 전화 통화, 즉석 회의, 일반적인 사무실 수다로 인한 끊임 없는 소음 -> 생산적 협업 x
- 따라서 엔지니어가 방해받지 않고 일정시간 동안 혼자서 집중할 수 있는 조용한 구역 지정도 필요

### 도구 및 기술적 고려사항
- 소프트웨어 엔지니어링 팀이 사용하는 도구와 기술적 고려사항 -> 효율성, 생산성 영향
- 신뢰할 수 있는 최신 도구, 기술 -> 업무 흐름 간소화, 지루한 작업 자동화 -> 팀원들이 더 중요한 업무에 집중
- 반대로 버그가 많고 신뢰할 수 없는 도구 -> 시간 낭비, 업무 추진력 방해
- e.g. 많은 시간이 소요되는 수동 검증 테스트를 하면서 마감일을 맞추기 위한 상황
	- 테스트 프레임 워크가 거짓 양성 오류(False positive error)를 찾아낸다고 생각해볼 것

### 코드 상태
- 코드 상태(Code health)는 유지 관리 가능성, 가독성, 안정성, 단순성 측면에서
	- 코드의 품질 상태를 측정하여 소프트웨어 엔지니어링 팀의 효과성과 효율성에 기여
- 기술 부채 또는 시간이 지남에 따라 코드 문제 누적 -> 개발 속도 저하, 버그 및 기타 문제 해결시 추가 비용
- 코드 상태 개선을 위해 클린 코드 관행을 따르고
	- 정기적인 코드 리뷰를 수행하여 문제가 발생하기 전 잠재적 문제 식별 필요

### 요약
- 상기 요소들은 소프트웨어 개발 프로세스를 다양한 방향으로 이끌 수 있음
- 소프트웨어 엔지니어링의 효율성, 효과성을 높이려면
	- 이들간의 적절한 균형이 필요

# 2.2. 성과 vs 결과물
- 효율성, 생산성 -> 결과물의 측정
	- 효과성 -> 성과
- 긍정적인 결과물 -> 긍정적인 성과로 이어지지는 않음
	- 때로는 생산성, 효율성이 높은 팀도 효과성이 떨어질 수 있음
- 결과물과 성과의 차이를 이해하면 개인과 팀이 더 효율적, 효과적, 생산적일 수 있음
- 결과물(output): 엔지니어링 작업으로 만들어진 산출물
	- 어떤 작업이 진행되었거나 팀이 어떤 업무를 수행했음을 보여줌
- 성과(outcome): 수행한 업무의 실제 결과
	- 성과는 팀의 노력이 긍정적이고 가치 있는 변화를 가져왔다는 것을 보여줌
- 결과물은 특정 활동이나 프로젝트를 통해 만들어진 실제 제품이나 서비스
	- 반드시 필요하긴 하나, 프로젝트의 궁극적인 목표나 목적을 항상 반영하지는 않음
- 성과는 프로젝트의 결과로 나타나는 변화 또는 이익
	- 프로젝트에서 달성하고자 하는 궁극적인 목표이기도 함

#### 결과물 및 성과에 대한 예시

|    결과물     |        성과         |
| :--------: | :---------------: |
| 새로운 app 출시 |  더 많은 사용자 확보에 도움  |
|  코드 리팩토링   |     코드 성능 개선      |
| 새로운 기능 추가  |     사용자 경험 개선     |
| 디자인 문서 발생  |    개발 프로세스 간소화    |
|  새 API 배포  | 다른 기업과의 원활한 협업 진행 |
|    작업량     |      비즈니스 가치      |
|     속도     |       투자 비용       |
|     품질     |      사용자 채택률      |
|     정원     |                   |
|   코드 상태    |                   |

## 2.2.1. 결과물 및 성과 측정 방법
- 결과물과 성과에 대한 측정 방법이
	- 효율성, 효과성, 생산성 측정에 사용되는 측정방법과 비슷하다?
	- 결과물과 성과 측정에 사용하는 지표는 효율성, 효과성, 생산성을 측정하는 방법의 핵심을 이룸
- 결과물은 수행한 활동에 따라 달라짐
	- 결과물은 대개 수치화된 데이터로 측정할 수 있으며 이를 통해 목표 달성 여부 확인 가능
	- 결과물은 보고, 검증하기 쉬움
- 결과물 측정 지표
	- 작업량(Throughput): 생산된 제품의 수
	- 속도(Velocity): 제품이 개발되는 과정의 속도
	- 품질(Quality): 고객이 기대하는 기준에 따라 식별한 결함 수
	- 정원(Capacity): 프로젝트를 작업할 수 있는 엔지니어 수
	- 코드 상태(Code health): 코드 리뷰를 통해 측정한 기술 부채의 감소율
- 성과는 수행한 활동의 영향력에 따라 달라짐
	- 성과는 질적 측면, 양적 측면이 모두 존재 -> 검증하기 더 까다로움
	- 또한, 성과 측정 방법은 서비스를 이용하는 사람들의 인식에 따라 크게 달라짐
	- 사용자의 인식은 주관적, 사용자마다 다른 특정 요구사항과 기대치가 존재할 수 있기에
		- 성과를 측정하거나 보고하기 위해서는 많은 노력 필요
- 성과를 측정하는 데 도움이 되는 몇 가지 지표 -> 효과성을 측정하는 데 사용하는 지표와 매우 유사
	- 비즈니스 가치(Business Value)
		- 소프트웨어 제품 엔지니어링의 성과 -> 비즈니스에 추가적인 수익, 비용 절감 가능
		- 제품이 제공하는 비즈니스 가치, 제품이 비즈니스의 전반적인 목표, 목적에 기여하는 부가가치
		- 새로운 기능으로 인한 수익이나 프로세스 개선으로 비용 절감 가능
	- 투자 비용(Investment)
		- 목표한 성과를 달성하기 위해 투입한 비용, 신제품 출시에 할당된 예산
		- 제품 개발을 위한 초기 투자 비용이 높으면 달성한 성과의 가치 감소 가능
	- 사용자 채택률(User Adoption)
		- 수행한 작업 적용 후 전체 사용자 대비 신규 사용자 비율
		- 높은 사용자 채택률은 낮은 채택률보다 더 나은 성과,
			- 이는 제품의 비즈니스 가치 창출에 기여
- 어떤 성과를 얻고자 하는지에 따라 중요하게 생각해야할 결과물이 달라짐
	- 목표로 할 결과물이 무엇인지 알아낼 수 있다면, 이를 달성하기 위한 작업을 수행함으로써 원하는 성과를 얻을 수 있음
	- 지멘스 헬스 서비스(SHS)의 사례 연구 참고

### 지멘스 헬스 서비스(Siemens Health Services) 사례 연구
- 성과 개선을 위해 애자일 방식 도입
	- 그들이 사용하는 결과물 지표가 프로젝트에 대한 명확한 시각을 제공하는데 부족함
	- 예정된 완료일까지 계획한 사용자 스토리를 제대로 완성할 수 없기 때문
		- 그들의 개발 속도가 합리적이라고 측정했음에도 불구하고
- 그 이유는 SHS가 예상 완료일을 계산할 때 충분히 검증되지 않은 지표를 확인하고 있었기 때문
	- e.g. 스프린트 검토에서 진행속도가 양호해 보이는 경우에도 많은 사용자 스토리가 중단되거나 미완성 상태
	- 스프린트에서 계획했던 많은 기능은 해당 스프린트가 끝날 때에도 '진행중' 상태로 남음
- 그래서 SHS는 접근 방식 변경
	- SHS 팀들은 원하는 성과, **즉 달성하고자 하는 궁극적인 목표를 파악하는 것부터 시작**
	- 이러한 관점 전환을 통해 SHS는 중요한 결과물이 무엇인지 정확하게 파악하는 것이 곧 발전의 핵심
	- 이후 그들은 진행 중인 작업, 작업 주기, 작업량과 같이 실행 가능한 작업 흐름을 측정하는 지표에 집중함
- 이렇게 성과 중심 지표로 전환한 후, SHS는 놀라운 변화 경험
	- 팀의 노력으로 작업 주기가 42% 단축, 운영 효율성, 품질 및 협업이 크게 개선
	- 성과에 집중하여 SHS는 올바른 결과물 식별 및 측정 가능했음

## 2.2.2. 결과물보다 성과에 집중하기
- 원하는 성과를 달성하는 데 초점을 두면 프로젝트를 장기적인 성공으로 이끌 수 있음
	- 결과물보다 성과에 집중하는 것은 조직과 개인의 성공을
		- 단순히 투입한 업무량으로 측정하기보다, 달성한 결과를 기준으로 측정함
	- 결국, 프로젝트의 장기적인 성공을 위해 프로젝트의 성과에 도움이 될 결과를 긍정적으로 평가하는 것이 중요
- 생산성, 효율성 및 결과물은 소프트웨어 생명주기에 따라 다양한 도구 활용으로 측정 가능
	- Github, Jira, Trello, Azure Devops
	- 코드의 양과 시간, 진행 상황 및 결함 수를 추적하고 보고하는 여러 유용한 기능 내장
	- 하지만 결과물을 간단하게 측정할 수 있다고 해서 결과물만 확인하는 **생산성 측정의 함정**에 빠지지 않도록 주의할 것
	- 위 접근 방식에는 몇 가지 문제점이 있음

### 정확한 측정의 어려움
- 팀 내에는 많은 사람이 서로 다른 시간에 각기 다른 작업 수행
- 팀 내에서 개인이 생산한 결과물만 따로 떼어놓고 측정하는 것은 사실상 불가능
- e.g. 어떤 팀원이 오래된 코드를 리팩터링 함
	- 다른 팀원은 새로운 기능 구현 혹은 기존 버그 수정 작업 진행한다면,
	- 모든 작ㄷ업은 소프트웨어 제품이라는 더 큰 목표를 위한 필수적인 작업이기에
	- 어떤 작업이 다른 작업보다 특별히 덜 중요하다고 말하기 어려움

### 가치 없는 과잉 생산
- 팀에서 결과물을 찍어내는 데에만 집중하면
	- 그저 찍어내고 있는 결과물이 실제로 도움이 되거나 가치가 있는지
	- 즉 결과물이 좋은 성과로 이어지는지는 상관하지 않을 수 있음
- 그저 결과물을 최대한 많이 생산해야 한다는 의무감이나 압박감에 사로잡힐 수 있음
- 대표적으로 Windows Vista가 새로운 기능을 구현하는데에만 집중한 나머지
	- 나머지 소프트웨어가 비대해지고
	- 기존 하드웨어와의 호환성 문제 발생

### 합리적이지 않은 마감일
- 소프트웨어 프로젝트에서 마감일을 합리적으로 설정하는 것은 매우 중요함
- 비현실적인 마감일은 날림으로 마무리한 결과물로 인해 작업의 완성도 하락
	- 오류 버그 위험 증가, 결과물 품질 저하
- 프로젝트 팀은 요구사항을 제대로 평가하는데 가장 적합하기에
	- 마감일을 확실히 챙길 수 있도록 소프트웨어 추정 작업에 참여해야 함
- e.g. 미국의 HealthCare.gov 출시 실패 이유 중 하나 -> 계획된 일정 압박
	- 출시 날짜가 건강보험개혁법에 명시되어 있었기 때문에
	- 보건복지후(HHS) 직원들은 완성도, 수행 테스트, 해결한 문제의 양이나 결과에 상관 없이
	- 제시간에 출시해야 한다는 압박을 받음

### 번아웃
- 생산성, 효율성을 높이기 위한 경쟁 -> 피로감, 번아웃
- 매일 더 많은 것을 만들어내기 위해 자신 또는 다른 사람들과 끊임 없이 경쟁하면
	- 결과물이 원하는 목표와 성과에 더 가까워지지 못하는 상황 간과 가능
- 이로 인해 정신적, 육체적 피로 누적 가능
	- 장기적으로 진행되는 프로젝트에 대한 지루함으로 이어질 수 있음

결과물에만 집중한다면 [[수박 효과]]가 발생할 수 있음
- 수박 겉할기 식 지표가 문제가 되는 이뉴는 진행 상황, 성공에 대한 **잘못된 인식**
	- 근본적인 문제를 개선하기 위한 조치에 소홀해짐
- 이러한 지표의 문제점은 하기와 같음
	- 작성된 코드 줄 수는 많음. 하지만 너무 많은 코드 작성 -> 버그, 기술 부채, 성능 문제
		- 비효율적인 코딩 관행을 따르는 것
	- 버그의 심각성, 재발 빈도를 고려하지 않고 단순히 수정된 버그 수 측정
		- 소프트웨어 품질을 정확하게 나타내기 힘듦
	- 제공된 기능의 수가 서류상으로는 긍정적인 지표로 보이나
		- 고객의 요구사항을 충족하지 못하는 낮은 가치의 기능이라면 이는 [[false-positive]]임

성과를 측정하는 것은 결과물을 측정하는 것보다 더 복잡함
- 수익 혹은 비즈니스 가치를 산출하거나 추정하려면
	- 비즈니스 인사이트와 사용자 조사 데이터가 필요함
- 엔지니어링 팀을 이끄는 경우, 이는 제품 팀이나 프로젝트에 관련된 비즈니스 이해관계자를 통해
	- 지속적으로 조사 정보를 파악해야 한다는 것을 의미
- 그리고 만약 이런 정보수집의 연결이 끊기게 되면
	- 프로젝트 진행에 문제가 생길 수 있음

예시: 테크리드 브라이언, 자신이 맡은 역할 중 기술적인 방면에 제일 열정적
- 브라이언은 높은 수준의 PR과 명확한 디자인 문서, 강력한 보안, 개인정보 보호, 위험 관리 계획을 부지런히 만듦
	- 그는 업무의 결과물을 훌륭하게 만들어냈고, PR 수, 가동률 및 기타 지표에 대해 능숙한 논의가 가능했음
- 하지만 브라이언은 지속적 성과 내기가 어려움
	- 비즈니스 관점에서, 이 프로젝트는 고객이 우선시하는 문제를 해결하여 성과 창출하는데 도움 필요
	- 불행히도, 프로젝트는 새로우나 다소 모호한 영역에서 운영되었기에
		- 모두가 함께 방향을 잡아 나아가야 했음
	- 제품 팀이 비즈니스, 시장의 요구를 더 잘 반영하기 위해
		- 조사 결과를 바탕으로 전략을 조정할 때, 브라이언은 좌절감을 느낌
	- 그는 이러한 조정 작업이 프로젝트 성과를 위해 정말 최선인지 의문을 가짐
- 브라이언은 팀이 결과물을 만들어온 경험을 토대로
	- 팀원들이 사용자에게 필요한 것이 무엇인지 충분히 이해할 수 있을 것이라 믿음
	- 하지만 브라이언은 비즈니스 최적화 목표, 의사결정이 만드는 장기적인 영향을 전혀 고려하지 x
	- e.g. 현재 작업중인 결과물 출시를 위해 2-3년이라는 기간동안 팀을 이 프로젝트에만 묶어야했음
- 브라이언에게 이 사실을 설명하려고 노력했으나, 브라이언은 자신이 만들고 이끌 수 있는 결과물에만 집중하고 싶어함
	- 그는 제품 팀이나 경영진과 같은 다른 사람들의 비즈니스 성과를 고민하고
	- 그 타당성을 자신에게 설득해주기를 바람
- 결국 브라이언은 자신의 신념 != 회사의 신념 -> 팀을 떠나기로 결정
	- 이 경험을 바탕으로
	- 프로젝트 초기에 프로젝트가 비즈니스에서 달성하고자 하는 성과와 어떻게 연결되는지 명확하고 분명하게 언급하고,
	- 관련 된 엔지니어들에게 이 메세지를 일관되게 전달하고자 노력하게 됨
- **팀 리더는 비즈니스에서 목표하는 성과를 완전히 파악하고 이를 팀원들에게 명확하게 전달해야 함**
	- 성과에 집중한다면 팀이 목표를 향해 나아가고 있는지, 자원이 효과적으로 사용되고 있는지 확실하게 파악할 수 있음
	- 또한 팀의 체계나 프로세스에서 무엇이 효과가 있고 없는지를 이해하고
		- 이를 조정하기가 쉬워짐
	- 이는 성과 향상, 효율성 증대, 유의미한 영향력으로 이어질 수 있으며
		- 궁극적으로 조직과 개인 모두에게 더 의미 있는 성공의 척도가 될 수 있음
- 요컨데, 성과에 집중하면 조직과 개인이 보다 의미 있는 성공을 거둘 수 있음

# 2.3. 효과적인 효율성
- 일을 올바르게 수행하는 것, 올바른 일을 하는 것 -> 모두 중요
- 이상적인 목표 -> 올바른 일을 올바르게 하는 것
	- 효과적으로 효율성 달성
- 효과적으로 효과적인 팀이 되는 방법
	- 일을 올바르게 수행하기
	- 올바른 일을 하기
	- 이상적으로는, 올바른 일을 올바르게 수행하기
- 효과적인 효율성을 달성하는 몇 가지 단계
	- 효과성과 효율성은 다름
	- 효과적인 효율성을 달성하기 위한 절충은 필요
- 이 절충이 무엇인지와 균형잡힌 절충안을 찾는데 도움이 되는 내용 기술

## 2.3.1. 초심자를 위한 효과적인 효율성
- 올바른 일을 올바르게 수행할 때의 원칙
	- 개인 ~ 조직까지 모두에게 적용 가능
- 효과적인 효율성을 추구하는 개인 단위의 초심자
	- 초심자는 효율성에 사로잡혀 자신의 생산성 수준을 높이는 데만 급급할 수 있음
	- 더 높은 효율성을 위해 도구, 기술, 패턴 같은 것에 시간을 투자하게 될 수도 있음
	- 때론 효율성에 대한 투자가 지나치면
		- 코드를 간결하게 만들기 위한 최적화 과정에서 가독성을 해치기도 함
	- 이러한 방식은 단기적으로는 효율적일 수는 있으나, 장기적으로는 x
	- 결국, 초심자는 특정 지표의 수치를 호전시켜 높은 효율성을 달성했다고 증명하고 싶어하나,
		- 이러한 노력이 고객과 비즈니스를 위한 더 좋은 성과로 이어진다고 장담 x
- 초심자가 흔히 보이는 또 다른 패턴, 업무의 기술적인 측면에 지나치게 치중
- 개발자 경험 팀의 스타 개발자인 제인의 예시
	- 훌륭한 디자인 문서, 잘 정리된 PR 작성
	- 종종 기술적인 초점만 맞춘 나머지 회사의 전반적인 비즈니스 목표를 놓침
	- 개발하던 고급 기능은 기술적으로는 혁신적이었으나, 사용자의 요구에는 부합하지 않았음
	- 이 업무가 연간 계획의 일부가 아니고 우리의 전략과도 부합하지 않다고 말했으나
		- 제인은 아랑곳하지 않고 계속해서 기능개발 진행
	- 인식의 차이 확인 후, 제인에게 서비스 인프라 팀의 제품 매니저와 협업하게 함
		- 프로젝트를 보다 넓은 시야에서 바라볼 수 있는 환경 제공
	- 협업이 전환점이 되어, 제인은 자신의 업무가 실제 어떻게 적용하는지 이해하며
		- 단순히 코드만 주목하는 게 아닌, 최종 사용자와 우리의 전략적 목표에 어떤 영향을 미치는지 살피게 됨
	- 또한, 다양한 시간대에 있는 비기술직군의 이해관계자들에게 제인의 기술 솔루션을 주기적으로 발표하는 시간 마련
		- 이러한 발표는 제인의 시야를 넓히고, 제인이 맡은 업무를 우리가 가진 전 세계적인 목표와 일치하는데 도움이 됨
		- 제인이 겪은 발전은 기술적 능력, 비즈니스 및 사용자 요구사항에 대한 깊은 이해를 조화시키는 것이 얼마나 중요한지 보여줌
- **엔지니어는 자신이 맡은 업무 맥락과 상황을 이해하는 것이 굉장히 중요**
	- 이러한 이해가 바탕이 되어야 자신들이 만드는 코드를 업무의 맥락에 맞게 변경할 수 있기 때문
	- 그리고 이를 통해 엔지니어들은 가독성, 유지보수성을 위해
		- 코드 품질이나 추상화 측면을 어느 정도까지 타협할지 판단할 수 있게 됨
	- 마찬가지로, 테스트 엔지니어는 업무의 맥락을 바탕으로 어떤 기능이 우선순위가 높은지 판단함
- 효과적인 효율성의 달성 -> 실용주의를 앞세우며 자신이 처한 상황과 맥락 이해 포함
- 개발자가 효과적인 효율성을 달성하는 방법은 아래와 같음

#### 질문을 통한 접근
- 초심자는 코딩을 시작하기에 앞서 더 큰 그림을 보는 것이 좋음
	- 때로는 스스로 문제를 해결하기 위해 시간을 들여 연구를 진행하고 싶을 수 있으나
	- 필요한 정보를 즉각 입수할 수 없다면 자신이 가진 비즈니스 영역에 대한 이해도와
		- 소프트웨어 기술 아키텍처에 대한 이해도 사이의 거리를 좁히기 위해
		- 구체적으로 질문을 해야함
- 선임 엔지니어이자 매니저인 한 동료, 자신의 팀에 20분 규칙을 따르길 제안
	- **문제에 봉착했을 때 처음 20분은 스스로 문제를 해결하기 위해 그 문제 분석 및 연구**
		- 그 후 다른 사람에게 질문을 던지기도 하고, 연구한 결과와 발견한 것들을 공유할 것
	- 이러한 20분 규칙을 통해 질문을 하기 이전에 문제나 업무와 관련된 요구사항, 제약을 더 잘 이해할 수 있게 됨
		- 이를 바탕으로 필요한 정보에 기반한 결정을 내리고,
		- 더 높은 품질과 코드를 생산할 수 있게 됨
	- 20분 규칙에는 개발자가 너무 늦지 않게 질문을 던질 기회를 줌으로써
		- 개발 과정 초기부터 문제가 될 만한 위험 요소를 파악할 가능성을 높임
	- 마찬가지로, 테스터는 무엇을 검증해야 할지에 대하여 잘 이해하게 됨
	- 이를 통해 일정 지연을 예방함과 동시에 고객의 기대에도 부응

#### 표준 준수
- 개발자들이 (특히 자신의 컴퓨터에서만) 코드가 돌아가는 것만을 목표로 삼는다면
	- 좋지 않은 코딩 관행에 의존할 수 있음
	- 파라미터 하드코딩, edge case 미고려, 꼭 필요한 주석을 남기지 않는 등
- 이러한 나쁜 관행은 빠른 결과를 낼 수 있으나
	- 코드 리뷰와 문제 해결에 더 많은 시간을 소모하게 만들어 결국 전체 개발 과정을 지연시킴
- 반면에, 시작부터 좋은 코딩 관행을 코드 작성 과정에 일부분으로 삼는다면
	- PR 병합은 약간 느려지겠으나, 결과적으로는 성공적이 PR 작성이 될 것

#### 협력하기
- 개발자와 테스터는 공식적인 팀 회의가 아니더라도
	- 다른 팀과 소통하고 협력할 수 있음
- 이러한 아이디어 교류는 목표에 대한 이해도 향상
	- 도구나 코드, 패턴 같은 것들을 재사용할 방안을 떠올리게 할 수도 있음
- 효율성, 효과성 모두 증대

#### 적절한 도구 사용하기
- 개발자는 필요에 따라 알맞은 도구 활용 필요
- VS Code, 확장 프로그램, 플러그인 활용
	- 생산성 극대화, 고품질의 오류 없는 코드 작성에 도움

### 요약
- 이러한 행동은 따로 떼어놓고 보면 중요하지 않아보이기도 함
- 하지만 **질문을 통한 접근, 표준 준수, 협력하기, 적절한 도구 사용하기** 같은 것들은
	- 개발자로 하여금 효과적인 효율성을 달성하는데 큰 도움이 됨
- 이러한 실천법은 적절한 작업 속도와 사고 방식을 정착시켜 작업 흐름을 개선하고
	- 코드 품질을 향상 시키며 프로젝트 성공 보장
- 결국, 협력, 표준 준수, 질문을 통한 접근과 같은 모범 사례를 따르는 것이 인기 있는 이뉴는
	- 이러한 행동이 효과성, 효율성을 증진시키기 때문

## 2.3.2. 절충안을 찾기 위한 노력
- 효과성과 효율성을 향상시키는 행동이 완벽하게 어울리지 않을 수 있음
	- 과유불급
- 효율성을 위한 일이 효과성을 해칠 수도 있음
- 다음과 같은 상황 고민

#### 기술 선택
- 목표 달성을 위해 새롭고 효율적인 프로그래밍 언어, 아키텍처 패턴 선택
	- 학습에 시간이 걸리거나 예상치 못한 장애물 발생 가능
- 반면, 이미 팀에서 사용해본 경험, 익숙하고 검증된 기술이 목표 달성에 더 효과적일 수 있음

#### 테스트
- 하기 두가지 방식중 선택이 필요할 수 있음
	- 매우 효과적이지만 많은 시간과 자원이 드는 포괄적인 테스트 접근법
	- vs 모든 테스트를 수행하진 않지만 빠르게 수행할 수 있는 더 효율적인 테스트 접근법

#### 프로젝트 일정
- 프로젝트나 스프린트 완료에 필요한 시간은 개발 시작 전에 어떤 식으로는 추정은 가능하나
	- 일정을 탄력적으로 조정하는 것에는 한계가 있음
- 그래서 일정에 영향을 미칠 수 있는 포괄적 테스트 같은 것들은 일정 추정 시간에 반드시 포함시켜야 함
	- 그래도 마감 일정이 촉박하다면 해당 스프린트에 개발할 기능 범위를
	- 사용자에게 가장 중요한 기능에 우선순위를 두도록 절충안을 마련해야 함
- 혹은, 효율성을 극대화하기 위해 가능한 한 컴포넌트를 재사용하거나
	- 추가적인 시간을 들여 개발 계획을 세우는 것도 방법

#### 예산
- 프로젝트의 예산이 제한적인 경우 팀원들이 자유롭게 실험을 해볼 수 있는 시간과 자원 부족 가능
- 주어진 예산 내에서 효과적으로 목표를 달성할 수 있도록 효율적으로 업무 수행 필요

#### 장기적인 유지보수성
- 팀에 속한 개발자라면 코드의 유지보수를 고려해야함
- 아마도 조금씩 쌓여 가는 잠재적인 기술 부채, 생산성 사이에 절충안 고민 필요
- 고품질의 코드 작성과 더불어 수월한 유지보수의 중요성 강조
- 이러한 고민은 더 많은 시간, 고민이 들지만
	- 장기적으로는 효과적인 결과를 가져옴

#### 사용자의 요구
- 엔지니어는 사용자에게 중요한 영향을 끼치는 프로젝트의 기능, 컴포넌트가 무엇인지 고민 필요
- 또한 더 많은 시간과 자원을 필요로 하더라도 효과성에 초점을 맞춰야 함

절충안을 찾기 위한 노력은 도전적인 과제
- 하지만 여러 프로젝트를 진행하다 보면 더 좋은 절충안을 찾기 위한 경험이 쌓이기 마련
- 이러한 경험을 기반으로 사용자의 필요를 만족시키며
	- 장기적으로 유지보수가 용이하고
	- 프로젝트의 제약사항을 반영하는 고품질의 코드 생산 가능

에어비엔비의 전신인 Airbed and Breakfast는 빚에 허덕였었음
- 쥐꼬리만 한 예산으로 사용자의 우려를 해결하기 위한 창의적인 방안 마련이 필요했던 상황
- 팀원들은 사용자에게 진정으로 중요한 핵심 기능을 우선순위로
	- 또한 사용자 피드백을 통해 사진이 있는 게스트 프로필, 목록, 예약 시스템 같은 기능이
	- 에어비엔비 호스트들에게 더 큰 가치를 제공하는 기능임을 깨달음
	- 이러한 기능을 우선시
- 사용자 경험에 기반한 고급 검색 필터, 맞춤형 추천
	- 매력적인 기능이긴 하나 당시 에어비엔비가 제공하기엔 사치스러운 기능
	- 개발을 미룸

핵심 기능에만 집중하는 간소화 접근법은 화려하진 않으나 흔들리지 않는 강점이 있음
- 이 접근법을 통해 서비스를 신속히 출시함으로써 에어비엔비가 얼리 어답터 확보, 중요한 사용자 피드백 반영 가능
- 점진적으로, 하나씩 새로운 기능을 추가해 가며 에어비엔비의 기본기를 다져나감

여러 선택지 사이에서 타협점을 찾고 절충안 마련은 늘 있는 일,
- 이러한 절충안 관리는 효과적인 효율성을 달성하는데 필수

## 2.3.2. 팀 생산성을 보는 다른 시각
- 효과적인 효율성을 달성하고자 할 때 생산성은 효율성의 일부분임을 기억할 것
	- 팀에 적합한 현대적인 생산성 측정 지표를 사용하는 것은
	- 생산성과 효율성의 차이를 줄이는데 도움이 됨
	- 이러한 지표를 활용하면 팀의 상황에 맞는 기준으로 생산성을 정의할 수 있을 것
- 전통적인 생산성 지표는 반복 작업의 결과물을 측정하기 위해 설계됨
	- e.g. 데이터 입력 담당자가 입력한 기록물의 숫자
	- 손쉽게 정량화 가능
	- 수행하는 업무의 복잡성 설명하기에는 고려할 수 있는 변수의 수가 제한적
- 이러한 전통적인 지표들은 문제 해결, 설계, 복잡한 소프트웨어 시스템 개발과 같이
	- 지식 집약적 활동으로 이루어진 소프트웨어 엔지니어링 분야에서의 생산성 측정 부적합
	- 소프트웨어 엔지니어링에서의 결과물은 대부분의 경우 손으로 만질 수 없는 무형의 산출물
		- 이러한 산출물의 실제 가치를 측정하기 위해 시간, 노력 필요
	- e.g. 소프트웨어 시스템 자체의 가치는 그 소프트웨어의 기능성, 신뢰성, 유지보수성, 확장성, 사용성 같은 지표로 측정 가능
- 또한, 소프트웨어 엔지니어가 수행하는 업무는 정량화하기 어려운 활동이 많음
	- 이러한 활동이 팀의 전반적인 생산성에 큰 영향을 미치는 경우도 존재. 측정하기 더 까다로움
	- e.g. 회의 참석, 동료와의 토론, 새로운 기술 및 도구 학습 등에 쓰는 시간도
		- 소프트웨어 엔지니어 생산성에 영향을 미칠 수 있음
	- 이런 활동은 프로젝트 전반적인 성과 향상에 도움이 되나,
		- 작업량, 작업 속도와 같은 전통적인 생산성 지표로 파악 불가
- Github, 대표 협업 플랫폼, 최고의 개발자 경험 제공 최우선 과제
	- 개발자의 생산성 -> 개발자 경험에 직접적 영향
	- 생산적인 개발자 -> 행복한 개발자
	- Github은 개발자 생산성 개선하고자 노력함
	- 무언가를 개선하기 위해 개선하고자 하는 것을 먼저 측정
		- 협업 지표처럼 정확하게 개발자 생산성을 추적하는 것을 중요시 생각
	- 이는 AI 개발자 생산성에 큰 영향을 끼치는 요즘 시대에 더욱 중요해지고 있음
- Github에서 실시간 Dogfooding
	- 개발자들은 더 심층적인 협업 측정에 대한 필요성을 느낌
	- Slack, Jira, PR, 문서 등의 메신저나 협업 도구에서 수집된 데이터를 활용하여 전체론적 접근 방식 구상
		- 여기에는 동기, 비동기 의사소통을 모두 포함하도록 설계
- 결과적으로 [Github의 생산성과 협업 지표](https://thenewstack.io/github-developer-productivity-at-30-billion-messages-per-day/#:~:text=At%20GitHub%2C%20these%20productivity%20metrics%20include%3A)는 다음 질문을 바탕으로 만들어짐

#### Github의 생산성과 협업 지표
- 사용자 피드백을 받는 데 걸리는 시간
	- 개발자가 얼마나 빨리 유용한 의견을 전달받을 수 있는가
- 비동기적 의사소통
	- 개발자가 얼마나 효과적으로 실시간이 아닌 의사소통 채널로 협업할 수 있은가
- 집중 작업 시간대
	- 개발자가 얼ㄹ마나 많은 시간 동안 방해받지 않고 몰입해서 업무 수행이 가능한가
- 새로운 문제 해결
	- 개발자가 얼마나 많은 시간을 신기하고 독특한 도전 과제 해결에 사용하는가
- 코드 작성과 버그 수정
	- 개발과 버그 수정 사이의 균형은 어떻게 이루어지는가
- 보안과 취약점
	- 보안 이슈는 얼마나 빈번하게 발생하며, 어떻게 처리되는가
- 역량 강화
	- 제품 개발 기간 동안 자신이나 다른 사람을 위해 얼마나 많은 시간을 학습과 발전에 투자하는가
- 자동화 테스트
	- 자동화 테스트를 만들고 관리하기 위해 얼마나 많은 시간을 사용하는가
- Context Switching
	- 개발자는 얼마나 빈번하게 업무를 전환하고,
	- 이런 전환이 생산성에 어떤 영향을 미치는가
- 주관적 웰빙
	- 개발자들은 자신들이 얼마나 생산적이라고 생각하는가
- 회의 문화
	- 개발자들은 자신들이 꼭 필요한 회의에 참석하고 있다 생각하는가

#### Github의 협업 지표 (후술)
- 깃허브는 이런 세분화된 지표를 종합하여 자사의 서비스를 넓은 시야로 관찰
	- 이는 생산성과 개발자 경험의 최적화를 이끌어내 궁극적으로는 플랫폼의 성공에 기여
- 이러한 이유로 소프트웨어 엔지니어링 리더는 구식이 된 전통적인 지표를 사용하지 않으면서
	- 자신이 맡고 있는 프로젝트에서 생산성이 무엇을 뜻하는지 명확히 밝혀야 함
	- 다시 말해 리더는 소프트웨어 엔지니어링 업무의 고유한 특성을 고려함과 동시에
		- 성과와 품질, 가치에 집중하는 새로운 접근 방법으로 생산성 측정 필요
	- 이런 새로운 생산성 지표는 팀이 고객을 위한 올바른 결과물을 만들고 있는지 확인 가능하며,
		- 그러한 과정에서 팀원이 행복하고 건강하게 일하고 있는지도 알려줌
- 최적화된 결과를 위해 개인적인 수준뿐만 아니라 프로젝트나 팀 수준에서 생산성 지표 정의
- 개인적인 수준의 생산성 지표 측정을 위해 팀에서는 SMART 목표를 사용할 수 있음
	- SMART 목표라 함은 다음과 같음
		- 구체적이고(Specific)
		- 측정 가능하며(Measurable)
		- 달성 가능하며(Achievable)
		- 현실적이고 관련성이 있으며(Relevant)
		- 기한이 정해져 있는(Time-based)
	- SMART 방법론의 주된 목적은 실행 가능하고 달성 가능한 목표를 짜임새 있는 방식으로 정리하기 위한 틀을 제공하는 것
- 팀 수준에서는 다음과 같은 두 가지 기법으로 현실적이고 관련성 있는 생산성 지표 정의 가능
