---
date: 2024-06-13
datetime: 2024-06-13 21:26:43
book: 실전_LLM
page:
  - "91"
tags: 
references: 
aliases:
---
- 사용자 경험을 향상 시키기 위해, 이를 분석하려면 어떻게 해야할까?
- LLM의 학습 능력을 활용하여 전체 과정을 완성하고
	- 유용한 end-to-end LLM 기반 app을 생성하고자 할 수 있음
	- 이때 prompt-engineering을 사용

# 3.2. 프롬프트 엔지니어링
- 프롬프트 엔지니어링은
	- 효과적으로 작업을 전달하여 정확하고 유용한 출력을 반환하도록 유도하는
	- LLM에 대한 입력(프롬프트)를 만드는 것

## 3.2.1. 언어 모델에서 정렬
- 언어 모델이 어떻게 사람의 입력에 **정렬**되는 지를 알아야 함
- 정렬(Alignment)
	- 모델이 사용자가 예상한 것과 '일치하는' 방식으로 입력 프롬프트를 이해하고 답변하는 것
- 표준언어 모델링은 선형 단어의 맥락을 기반으로
	- 다음 단어나, 단어의 시퀀스를 예측하도록 훈련됨
- 하지만 이 방식으로는 모델이 **특정 지시사항**이나 **프롬프트**에 완벽히 답변 불가
	- 특정 어플리케이션에 대해서는 유용하지 않을 수 있음
- 프롬프트가 언어 모델과 align되지 않는다면 잘못 답변 가능
- 몇몇 언어 모델은 추가적인 정렬 기능과 함께 개발됨
	- Anthropic의 AI 피드백 기반 강화 학습(RLAIF; Constitutional AI-driven Reinforcement Learning from AI feedback)
	- OpenAI의 GPT 계열에서의 인간 피드백 강화 학습(RLHF; Reinforcement Learning from Human Feedback)
	- 명확한 지시사항과 피드백을 모델 훈련에 통합 가능
- 정렬 기술은 특정 프롬프트를 **이해하고 답변하는 모델의 능력 향상**으로
	- 질문-답변이나 언어 번역과 같은 app을 유용하게 만들 수 있음
- 아래 모델들은 대량의 데이터와 전이학습, 파인튜닝 등의 기술을 사용하여 명령어 프롬프트에 대한 답변을 보다 효과적으로 생성 가능
	- ChatGPT: OpenAI closed source model
	- FLAN-T5: Google open source
	- Cohere 명령어 계열: closed source model

## 3.2.2. 직접 요청하기
- 요청하는 내용이 최대한 명확하고 직접적이어야 함
- LLM이 수행하기에 간단하고 명백한 작업
	- e.g. '이 문장의 문법을 수정하세요'
- 접두사 추가: 입력과 출력을 명확하게 표시
- 간단한 '직접 요청하기'의 세가지 요소
	- 직접적인 지시
		- '영어를 터키어로 번역하세요'
		- 이 지시는 프롬프트 상단에 위치해야함
		- LLM이 다음에 오는 입력 내용을 읽는 동안 주의를 기울이도록
	- 번역을 원하는 영어구문 앞 `영어: `를 추가하여 명확하게 입력 지정
	- LLM이 답변을 제공할 공간에 의도적으로 유사 접두사 `터키어:`를 추가
- 리스트 형태로 요청하기
```md
이 문장의 문법을 수정해 주세요
여러 개의 정답이 있으면, 숫자가 있는 목록으로 보여주세요

They went to the store and buy food

A:
1. They went to the store ...
2. They went to the store ...
```
- 적절한 지시사항이 떠오르지 않을 경우, 그냥 요청해도 됨
	- 다만, 정확하고 유용한 답변 출력시, 명확하고 직접적인 지시사항 필요

## 3.2.3. 퓨샷 학습
- LLM에게 예시를 제공하기
	- Few-shot learning
- LLM의 작업의 몇가지 예제를 제공하여, 문제의 맥락과 애매한 차이를 이해하는데 도움을 줌
- **특정한 어조**, **구문 또는 스타일**이 필요한 작업과
	- 도메인에 특화된 언어들을 다룰때 유용함
- LLM과의 상호작용 방식에 대한 **새로운 가능성**을 열어줌
- 명확한 지시를 제공하지 않고도 LLM에 대한 작업 이해도 제공 가능

## 3.2.4. 출력 구조화
- JSON과 같은 구조화된 형태로 출력 가능
- "최종 결과는 유효한 JSON 형식으로 만들어 주세요"
```md
영어를 터키어로 번역해 주세요.
최종 결과는 다음과 같은 유효한 JSON 형식으로 만들어 주세요

English: (영어 입력 문장)
JSON: "english": (입력 문장), "turkish": (번역된 터키어 버전)
```
- 개발자가 특정 정보를 더 쉽게 추출 및 다른 서비스로 제공 가능
- 출력의 일관성 보장, 모델 작업시 오류나 불일치의 위험 감소 가능

## 3.2.5. 페르소나 지정하기
- 연구자나 실무자들은 LLM을 위한 '페르소나'를 만들어,
	- 프롬프트에 따라 모델이 스타일이나 말투 채택 가능
- 특정 주제, 장르, 스타일이나 말투 채택 가능
- 특정 유형의 답변 유도 가능
- "가게 점원이라 생각하고 질문에 답을 하세요"
- "건방진 가게 점원이라 생각하고 질문에 답을 하세요"
- "반유대주의자 가게 점원이라 생각하고 질문에 답을 하세요"
- 항상 긍정적인 목적으로 사용되지는 않음
	- 유해한 목적으로도 생성 가능
- 윤리적으로 사용 필요

# 3.3. 여러 모델과 프롬프트 작업하기
- 프롬프트를 하나의 모델에서 작동하는 것이 다른 모델과 동일하게 작동 불가할 수 있음
- 각 언어 모델의 특징과 제한 사항 고려 필요

## 3.3.1. ChatGPT
- system, user, assistant 프롬프트 생성 가능
- system
	- 대화의 일반적인 지침
	- 일반적으로 따라야할 규칙과 역할 포함
- user, assistant
	- 사용자와 언어모델 간의 메세지

## 3.3.2. Cohere
- OpenAI의 대안으로 사용
- 프롬프트를 다른 모델로 간단하게 옮길 수 없음
- 다른 언어 모델이 작동할 수 있도록 프롬프트를 수정해야 할 수 있음
- ChatGPT보다 조금 더 구조적인 요구사항이 필요함

## 3.3.3. 오픈소스 프롬프트 엔지니어링
- `GPT-J, FLAN-T5`
- 위 모델 사용시, 사전 훈련과 파인 튜닝을 최대한 활용하기 위한 중요 단계
- closed source model과 같이 고품질의 텍스트 출력 생성 가능
- oepn source 모델은 closed보다 더 큰 유연성과 제어 기능을 제공함
	- 그에따라 개발자가 파인 튜닝 중 **프롬프트를 맞춤화하여 특정 사용 사례에 맞게 조정 가능**
- 다른 개발자 연구원과 협업할 수 있음
	- 다수의 활발한 사용자와 기여자로 이루어진 커뮤니티
	- 프롬프트 엔지니어링 전략을 공유하고 피드백을 주고 받으며, 모델 전반적인 성능 개선 가능
- 오픈소스 모델이 어떻게 사전훈련, 파인튜닝되었는지 파악하는 것은 매우 중요
	- GPT-J는 자기회귀 언어 모델
		- 직접적인 지시 프롬프트 보다 퓨삿 프롬프트 기술이 더 잘 동작
	- FLAN-T5
		- 지시적 프롬프팅을 고려하여 특별히 파인튜닝 됨
		- 퓨삿 학습은 여전히 가능하나, 직접 질문하는 간단한 방식도 사용 가능
- GPT-J는
	- 직접적인 지시사항 답변에 어려움을 겪음
- FLAN-T5
	- 지시어 수행 방법을 알고 있음
	- 주관적인 작업에서 어려움

# 3.4. ChatGPT와 Q/A 챗봇 만들기
- API Endpoint 중 하나는 자연어 질문을 받아 `BoolQ` 데이터셋에서 문서를 검색하는데 사용함
- Q/A 챗봇을 만들기 위해 해야할 일
	- ChatGPT를 위한 시스템 프롬프트 디자인
	- 새로운 사용자 메시지마다 저장된 지식에서 의미 검색
		- 벡터 데이터베이스에서 결과 검색
	- 데이터베이스에서 찾은 의미를 ChatGPT의 **시스템 프롬프트**에 삽입
	- ChatGPT가 알아서 질문에 답변 

## 코드 작성
- https://github.com/sinanuozdemir/quick-start-guide-to-llms/blob/main/notebooks/3_prompt_engineering.ipynb
```python
class ChatbotGPT():

	def __init__(self, system_prompt, threshold=.8):
		# 시스템 프롬프트 사용, 대화 목록의 첫번째 차례 초기화
		# 사용자 입력, 지식베이스간의 유사도 점수에 대한 threshold 설정
		pass
	
	def display_conversation(self):
		# 대화 각 턴 반복
		# 턴의 역할과 내용을 가져와
		# 역할과 내용을 읽기 쉬운 형식으로 출력
		pass

	def user_turn(self, message):
		# 사용자의 입력을 대화에 차례로 추가
		# pinecorn을 사용하여 지식 베이스에서 가장 잘 매칭되는 결과 가져오기
		# 사용자의 입력과 문서 사이의 신뢰 점수가 임계 값을 충족하는지 확인
		# OpenAI의 API를 사용하여 ChatGPT 모델로부터 답변 생성
		# GPT-3.5 답변을 대화의 한 턴으로 추가
		# 어시스턴트의 답변 리턴
		pass
```
- 초기 시스템 프롬프트
```python
SYSTEM_PROMPT = '''
You are a helpful Q/A bot that can only use reference material from a knowledge base.
If a user asks anything that is not "from the knowledge base", say that you cannot answer.
'''.strip()
```
- 당신은 지식 베이스의 자료만 참조할 수 있는 유용한 Q/A 봇입니다.
- 사용자가 '지식 베이스'가 아닌 내용을 묻는 경우 답변할 수 없다고 말합니다

# 3.5. 마치며
- 언어 모델의 성능을 향상시키기 위해 프롬프트 디자인 및 최적화 하는 과정은
	- 다소 반복적이며 까다로울 수 있음
- 정렬 이해하기, 직접 요청하기, 퓨샷 학습, 출력 구조화, 페르소나 지정하기, 여러모델과 프롬프트 작업하기
- 능숙한 프롬프트 엔지니어링과 효과적인 글쓰기 사이에는 강한 상관관계 존재
	- 명확한 지시, 원하는 답변 반환
	- LLM에도 잘 구조화되고 유용함
- 프롬프트가 여러 답변을 허용하거나 일반적으로 모호한 경우
	- 이는 LLM에도 좋지 않은 프롬프트
- 프롬프트 엔지니어링과 글쓰기는 유사함
	- 효과적인 프롬프트 작성은 전통적인 엔지니어링 작업보다
	- 데이터 주석 지침을 만들거나 숙련된 글쓰기에 가까움
- 프롬프트 엔지니어링 -> 언어 모델의 성능 향상에 중요한 과정
- 프롬프트 설계 및 최적화로
	- 언어 모델이 사용자의 입력을 더 잘 이해하고, 이에 정확한 답을 하도록 만들 수 있음
- 5장에서 아래와 같은 주제를 다룸
	- LLM 출력 검증
	- LLM이 생각하는 과정을 표현하기 위한 연쇄적 사고(Chain-of-Though) 프롬프트
	- 여러 프롬프트를 더 큰 워크플로에 연결
