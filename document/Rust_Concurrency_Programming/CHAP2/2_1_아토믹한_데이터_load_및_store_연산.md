---
date: 2024-07-05
datetime: 2024-07-05T23:29:00
book: 러스트_동시성_프로그래밍
page: 
tags: 
references: 
aliases:
---
# 아토믹(Atomic)
- 더 이상 작은 것으로 나누어 질 수 없음
- 완전히 수행되었거나 수행되지 않은 상태
- [[1_4_소유권_대여와_데이터_경합]]에서 처럼,
	- 여러 스레드가 동시에 동일한 변수를 읽고 변경하는 것은 정의되지 x
	- 하지만 아토믹 연산을 사용하면, 여러 스레드가 안전하게 동일한 변수의 RW 가능
- 하드웨어 수준에서 아토믹이 어떻게 작동하는지는 7장에서 언급 예정
- 아토믹 연산은 **멀티 스레드**와 관련된 모든 것의 기초가 됨
	- [[Mutex|뮤텍스]]나 [[1_8_대기_파킹과_조건_변수#1.8.2. 조건 변수|조건 변수]]와 같은 모든 동시성의 기본 구성 요소가 **아토믹 연산**으로 구현된 것들
- `std::sync::atomic`에 정의된 아토믹 타입들의 메서드로 사용 가능
- `AtomicI32`나 `AtomicUsize`와 같이 `Atomic`으로 시작하는 이름을 가짐
- 사용 가능한 아토믹 타입은 **하드웨어 아키텍처**와 **운영체제**에 따라 다르나,
	- 거의 모든 플랫폼에서 최소한 **단일 포인터 크기**까지의 모든 아토믹 타입을 제공
- 대부분의 타입들과 다르게, 아토믹 타입들은 [[reference_&T|공유 레퍼런스]](`&AtomicU8`)을 통한 값의 변경이 가능함
	- [[1_5_내부_가변성|내부 가변성]] 덕분에 가능한 일
- 아래 연산들에 대해 동일한 인터페이스를 가짐
	- `store-and-load`
	- `fetch-and-modify`
	- `compare-and-exchange`

## 메모리 순서(memory ordering)
- 모든 아토믹 연산은 `std::sync::atomic::Ordering` 타입의 파라미터를 입력 받음
- 아토믹 연산 간의 **상대적인 연산 순서**에 대해 무엇을 보장할지를 결정
	- 가장 적은 보장을 제공하는 간단한 변형은 `Relaxed`
- `Relaxed`는 **단일 아토믹 변수**에 대해 일관성을 보장하나,
	- 서로 다른 변수 사이의 **상대적인 연산 순서**는 아무것도 보장하지 x
- 두 스레드에서 변수들에 대한 연산이 **스레드마다 다른 순서로 발생**할 수 있다는 의미
	- e.g. A 스레드가 a 변수에 값을 쓰고, b 변수에 빠르게 쓸 경우
		- B 스레드에서는 해당 내용이 반대 순서로 발생하는 것처럼 보임
- 2장에서는 위 문제 대신 `Relaex`를 사용하여 아토믹 연산을 간단하게 살펴볼 예정