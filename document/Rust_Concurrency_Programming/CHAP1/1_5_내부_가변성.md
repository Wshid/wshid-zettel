---
date: 2024-05-08
datetime: 2024-05-08T22:12:00
book: 러스트_동시성_프로그래밍
page:
  - "35"
tags: 
references: 
aliases:
---
- 소유권 대여 규칙은 간단하지만
	- 멀티 스레드 환경에서는 명확한 한계점 존재
- 소유권 대여 규칙은
	- 정보 교환을 매우 제한적으로, 거의 불가능하게 만듦
	- 여러 스레드에서 접근 가능한 값은 수정될 수 없기 때문
- 내부 가변성(interior mutability)을 사용하면 이 문제 해결 가능
	- 내부 가변성을 가진 자료형은 소유권 대여 규칙을 살짝 우회함
	- 특정 조건이 만족하는 경우 불변 레퍼런스를 사용하여 참조하는 값 변경 가능
- [[rust_rc|Rc]]와 [[rust_arc|Arc]]는
	- 같은 레퍼런스 카운터를 사용하는 clone이 여러개 존재하는 상황에서도
	- 레퍼런스 카운터의 값을 변경함
- 내부 가변성 타입을 사용하면
	- 불변, 가변이라고 말하는 것은 때로는 부정확한 표현
	- 두 레퍼런스 모두 참조하는 값을 **변경**할 수 있기 때문
	- **공유, 독점**이라는 표현 사용
		- [[reference_&T|공유 레퍼런스]]는 복사되어 다른 코드에 공유 가능
		- [[독점 레퍼런스]]
- 공유 레퍼런스는 값을 변경할 수 없지만, 몇가지 예외 존재
- 내부 가변성은 값을 공유할 때 값을 변경하는 것을 허용하기 위해
	- 소유권을 공유 상태로 대여하는 경우의 규칙만 우회함
	- 독점 레퍼런스 관련해서는 아무것도 바뀌지 않음
- 독점적 소유권 대여의 경우, 여전히 단 하나의 **독점 레퍼런스**만 존재할 수 있음
	- 여러개의 독점 레퍼런스를 만드는 언세이프 코드는 내부 가변성과 상관없이 항상 정의되지 않은 동작 발생

### 1.5.1. Cell
- `std::cell:Cell<T>`
	- 단순히 `T`를 감싸고 있는 타입
	- 공유 레퍼런스로 값을 변경할 수 있음
- 값을 꺼내어 복사하거나, 값 전체를 다른 값으로 교체하는 것만 가능
- 이 작업은 단일 스레드에서만 가능
```rust
use std::cell:Cell;

fn f(a: &Cell<i32>, b: &Cell<i32>) {
	let before = a.get();
	b.set(b.get() + 1);
	let after = a.get();
	if before != after {
		x(); // 실행될 수도 있음
	}
}
```
- 이전 예시에서 `i32 -> Cell<i32>`로 변경
- if문 만족이 가능함
	- `Cell<i32>`의 내부 가변성 때문에
	- 컴파일러는 공유 레퍼런스가 존재하는 동안에는 더 이상 해당 변수의 값이 바뀌지 않는다고 가정할 수 없음
	- a와 b는 같은 값 참조 가능
	- b를 변경하는것이 a 값에 영향을 줄 수 있음
	- 단, 단일 스레드에서만 작동하는 상황만 가정함
- 위 제약은 `Cell`을 사용하기 더 어렵게 만드는 이유중 하나
	- Cell의 값을 직접 대여할 수 없으므로, `Cell`로부터 값을 꺼내고 다른 값을 채워 넣어야 함
```rust
fn f(v: &Cell<Vec<i32>>) {
	let mut v2 = v.take(); // Cell을 빈 Vec로 대체
	v2.push(1);
	v.set(v2); // 값이 변경된 Vec을 다시 입력
}
```