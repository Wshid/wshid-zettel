---
date: 2024-05-29
datetime: 2024-05-29 21:05:14
book: 러스트_동시성_프로그래밍
page:
  - "41"
tags: 
references: 
aliases:
---
[[Mutex]]

# 1.7.1. 러스트의 뮤텍스
- `std::sync::Mutex<T>`로 사용
	- 뮤텍스가 보호하고 있는 데이터의 타입인 `T`의 제네릭 형태
- `T`를 뮤텍스의 일부로 사용하면
	- 모든 스레드들이 오직 뮤텍스로 내부 데이터에 접근할 수 있는 안전한 인터페이스 제공
- 뮤텍스를 잠근 스레드만 잠금 해제 할 수 있도록
	- `unlock()`메서드를 가지지 않음
	- 대신, `lock()`에서 `MutexGuard`를 리턴함
- `MutexGuard`는 현재 뮤텍스가 잠겨있음을 의미
- `DerefMut` [[rust_trait|trait]]을 통해 [[독점 레퍼런스]]처럼 사용 가능
	- 뮤텍스가 보호하는 데이터에 접근 가능
- `MutexGaurd`가 drop되는 순간, 뮤텍스는 즉시 잠금 해제 상태가 됨
	- `MutexGaurd`가 drop되면 더 이상 현재 스레드에서 뮤텍스가 보호하는 데이터 접근 불가
	- `MutexGuard::Drop` [[rust_trait|trait]] 구현체가 뮤텍스의 잠금 해제 수행

```rust
use std::sync::Mutex;
fn main() {
	let n = Mutex::new(0);
	thread::scope(|s| {
		for _ in 0..10 {
			s.spawn(|| {
				let mut guard = n.lock().unwrap();
				for _ in 0..100 {
					*guard +=1;
				}
			});
		}	
	});
	assert_eq!(n.into_inner().unwrap(), 1000);
}
```
- 정수 값을 보호하는 `Mutex<i32>`를 선언
	- 총 10개의 스레드를 생성하여
	- 각각의 스레드에서 뮤텍스가 보호하는 정수를 100번 증가 시킴
- 각 스레드는 먼저 뮤텍스를 잠금상태로 만들어
	- `MutexGuard`를 얻은다음
	- `guard`를 이용해 정수에 접근하여 값을 1씩 증가시킴
	- `guard`는 범위를 벗어나면 drop됨
- 모든 스레드의 작업이 끝나면, 뮤텍스에서 `into_inner()`를 사용하여 안전하게 값 제거 가능
	- `into_inner()`
		- 뮤텍스의 소유권을 가져감
		- 더 이상 뮤텍스의 레퍼런스가 존재할 수 x
		- 더 이상 뮤텍스를 잠금 필요가 없어짐
- `for` 루프에서 정수를 1씩 증가 시켰으나,
	- 스레드들이 값을 증가시키기 시작하는 순간에, 정수가 항상 100의 배수를 값으로 가짐
	- **뮤텍스의 잠금이 해제**되어야만 값에 접근이 가능하기 때문
	- 뮤텍스 덕분에 정수의 값을 `100`씩 증가시키는 작업은
		- 더 이상 나눌 수 없는 `atomic`한 작업 단위가 됨

뮤텍스 잠금 전 1초를 기다리는 코드
```rust
use std::time::Duration;
fn main() {
	let n = Mutex.new(0);
	thread::scope(|s| {
		for _ in 0..10 {
			s.spawn(|| {
				let mut guard = n.lock().unwrap();
				for _ in 0..100 {
					*guard +=1;
				}
				thread::sleep(Duration::from_secs(1));
			});
		}
	});
	assert_eq!(n.into_inner().unwrap(), 1000);
}
``` 
- 프로그램 수행시 약 10초 정도 소요됨
- 스레드들이 각 1초를 기다리나, 한번에 한 스레드만 접근 가능하기 때문

`guard`를 강제로 메모리에서 삭제하면, 1초간 잠자기 상태 전 뮤텍스가 즉시 잠금 해제되어 동시 수행
```rust
use std::time::Duration;
fn main() {
	let n = Mutex::new(0);
	thread::scope(|s| {
		for _ in 0..10 {
			s.spawn(|| {
				let mut guard = n.lock().unwrap();
				for _ in 0..100 {
					*guard += 1;
				}
				drop(guard); // 스레드 대기 이전에 guard 제거
				thread::sleep(Duration::from_secs(1));
			});
		}
	});
	asert_eq!(n.into_inner().unwrap(), 1000);
}
```
- 프로그램은 단 1초만에 수행됨
- 뮤텍스를 잠금 상태로 만들었을 때, 소요되는 시간을 최소화 해야함
- 뮤텍스를 필요 이상으로 잠금 상태로 사용시
	- 병렬 처리의 이점이 사라지고, 작업이 순서대로 진행됨

# 1.7.2. 잠금 오염
- `unwrap()`은 [[잠금 오염]](lock poisoning)과 연관됨

## MutexGuard의 라이프 타임
- MutexGaurd가 drop 될때 [[Mutex]]가 잠금 해제되는 것은 매우 편리하나, 예상치 못한일이 발생할 수도 있음
- `MutexGaurd`의 변수 이름을 `let`을 사용해 선언하면,
	- 지역 변수는 선언된 범위를 벗어날 때 drop 되므로
	- 해당 변수가 언제 drop 되는지 예측 가능함
- 하지만 명시적으로 메모리에서 guard를 삭제하지 않는 것은
	- 뮤텍스를 필요 이상으로 잠금 상태로 오래 유지시킬 가능성 존재
- MutexGaurd를 **변수로 선언하지 않고** 사용하는 것도 가능함
	- 몇몇 케이스에서는 편함
- MutexGuard가 보호된 데이터에 대한 [[독점 레퍼런스]]처럼 동작하기 때문에, 변수로 만들지 않고 바로 사용 가능
- 예시
	- 한줄의 코드로 `Mutex<Vec<i32>>` 타입의 뮤텍스를 잠금 상태로 만들고
	- Vec에 새로운 원소를 추가한 다음 다시 뮤텍스를 잠금 해제
		```rust
		list.lock().unwrap().push(1);
		```
	- `lock()`이 리턴하는 `MutexGuard`와 같은 모든 임시 변수들은, 해당 선언문이 끝날 때 삭제 됨
		- 당연해보이지만, `match, if, let, while let`을 사용하는 경우 문제 발생  
		```rust
		if let Some(item) = list.lock().unwrap().pop() {
			process_item(item);
		}
		```
		- 리스트를 잠근 다음, 아이템을 하나 꺼내고, 리스트를 잠금 해제 한 후 다음 작업 처리
			- `MutexGuard`가 `if let` 문이 끝날 때 까지 제거되지 않음
			- 꺼낸 아이템을 처리하는 동안 Mutex가 잠금 상태로 남음
	- 단, 아래 코드는 문제가 발생하지 않음
		```rust
		if list.lock().unwrap().pop() == Some(1) {
			do_something();
		}
		```
		- `MutexGuard`가 if문이 시작되기 전에 삭제 됨
			- `if`문의 조건문은 항상 아무 값도 대여하지 않는 boolean 값이기 때문
			- 조건문에 사용된 변수를 `if`문 끝까지 연장할 필요가 없음
	- `if let`을 사용할 경우,
		- `pop()`이 아닌 `front()`를 쓴다면
			- `item`은 `list`로부터 값을 대여하므로 guard를 범위 안에 계속 유지해야 함
		- 대여 체커(borrow checker)는 여기서 검사만 진행,
			- 실제로 언제 그리고 무엇이 드랍되는지는 **영향을 주지 않아서** (`pop()`)을 사용하는 경우 같은 일 발생
	- 단, `pop()`을 별도 라인으로 분리하면 문제 해결
		- `guard`가 `if let`에 들어가기 전에 드랍
		```rust
		let item = list.lock().unwrap().pop();
		if let Some(item) = item {
			process_item(item);
		}
		```


# 1.7.3. 읽기/쓰기 잠금 
- [[Mutex|뮤텍스]]는 오직 독점적인 접근만을 다루는 자료형
- [[MutexGuard]]
- 읽기/쓰기 잠금은 약간 더 복잡
	- **독점적 접근**과 **공유적 접근**의 차이를 이해
- 세가지 상태
	- 잠금 해제
	- 단일 작성자(독점 접근)에 의한 잠금
	- 다수의 독자(공유 접근)에 의한 잠금
- 멀티 스레드 환경에서 대부분의 스레드가 값을 **읽기**만 하고
	- 값이 자주 변경되지 않을 때 유용함
- 러스트 표준 라이브러리는 읽기/쓰기 잠금을 `std::sync::RwLock<T>`로 제공
	- 일반 [[Mutex|뮤텍스]]와는 비슷하게 동작하나, 인터페이스가 두부분으로 나뉨
- `lock()`메서드 대신 `read()`, `write()`가 존재
- 가드 타입도 두 종류
	- `RwLockReadGuard`: `Deref`만 구현하여 [[reference_&T|공유 레퍼런스]] 처럼 동작
	- `RwLockWriteGuard`: `DerefMut`를 구현하여 [[독점 레퍼런스]] 처럼 동작
- **소유권 대여 규칙**이 준수되는지 확인하기 위해
	- 레퍼런스 수를 동적으로 추적하는 [[RefCell]]의 멀티스레드 버전
- `Mutex<T>`와 `RwLock<T>`는 모두 `T`가 [[Send]] [[rust_trait|trait]]을 구현해야 함
	- `T`를 다른 스레드로 보내는데 사용될 수 있기 때문
- 여러 스레드가 보호된 데이터에 대한 [[reference_&T|공유 레퍼런스]]를 보유할 수 있기 때문에
	- `RwLock<T>`는 추가로 `T`가 [[Sync]]도 구현해야 함
	- 엄격하게는 이러한 조건을 만족하지 않는 `T`에 대해 잠금 생성은 가능하나,
		- `Sync`를 구현하지 않으므로, 스레드간 값 공유는 불가
- 러스트 표준 라이브러리는 범용적인 [[RwLock]] 타입 한가지만 지원
	- 실제 구현은 OS마다 다소 다름
- 읽기/쓰기 잠금은 구현체마다 미묘한 차이 존재
- 대부분의 구현은 잠금이 **이미 읽기 잠금 상태**인 경우에도
	- 대기중인 작성자가 있으면, 새로운 독자를 **대기 상태**로 만듦
	-  [[writer starvation]] 을 방지하기 위함

### 다른 언어의 뮤텍스
- 러스트 표준 [[Mutex]]와 [[RwLock]]타입은 C와 C++ 같은 다른 언어와 약간 다름
- 가장 큰 차이점: 러스트의 `Mutex<T>`는 보호하고 있는 데이터를 **포함**
	- C++에서는 `std::mutex`가 보호하는 값을 포함 x
		- 어떤 값을 보호하는지도 확인 x
		- 이는, 어떤 값이 [[Mutex|뮤텍스]]에 의해 보호되기 있는지를 기억하고
			- 보호된 데이터에 접근할 때마다 올바른 뮤텍스가 잠금 상태가 되는지를 확인하는 것이
			- 모두 사용자의 책임
- 다른 언어의 뮤텍스 관련 코드를 살펴보거나, 러스트에 익숙하지 않은 사용자들과 커뮤니케이션시 유용함
	- 러스트 프로그래머: ‘뮤텍스 안의 데이터’, ‘뮤텍스로 감싸진 데이터’
	- 다른 언어 프로그래머: 이상한 이야기
- 외부 하드웨어를 보호하기 위해 아무 값도 갖지 않는 뮤텍스 자체만 필요하다면 `Mutex<()>` 사용 가능
- 하지만 이 경우에도, 해당 하드웨어와 상호 작용 가능한(아마도 크기가 0 일수 있음) 타입을 정의하고,
	- 이를 [[Mutex]]로 감싸는게 나을 수 있음
- 그럴경우, 하드웨어와 상호작용 하기 전에도 뮤텍스를 반드시 **잠금** 상태로 만들어야 하기 때문

## 1.8. 대기: 파킹과 조건 변수
- 데이터가 여러 스레드에 의해 값이 변경된다면
	- 스레드는 어떤 이벤트가 발생하거나, 데이터에 대한 특정 조건이 만족되기를 기다림
- e.g. 비어있는 Vec을 보호하는 [[Mutex]]가 있을 때,
	- 이 벡터가 어떤 값이든 담고 있기를 기다릴 수 있음
- [[Mutex]]는 여러 스레드가 뮤텍스의 잠금이 해제되기를 기다리는 것을 허용함
	- 하지만 다른 조건을 만족하는 걸 기다리도록 하는 기능은 제공 x
- 뮤텍스가 여러 스레드에서 값을 접근하고 변경하도록 하는 유일한 방법이라면,
	- 조건이 만족되는지 검사하기 위해 계속해서 뮤텍스를 잠금 상태로 변경, Vec에 어떤 값이 있는지 계획 확인 필요함
- [[Mutex]]는 잠금이 해제될 때까지 스레드가 대기할 수 있게 해주지만, 다른 조건을 기다리는 기능은 제공하지 않음
- 뮤텍스가 전부라면, 뮤텍스를 계속 잠그고 `Vec`에 아직 아무것도 없는지 반복해서 확인 필요

### 1.8.1. 스레드 파킹
- 다른 스레드의 알림을 기다리는 방법 중 하나
- 스레드 파킹 상태에서는 CPU 사이클을 소모하지 않음
- 스레드는 스스로를 park할 수 있으며, 다른 스레드가 파킹된 스레드를 unpark 할 수 있음
- `std::thread::park()`을 사용하여 스레드 파킹 가능
	- `unpark()`을 파킹 해제하기 원하는 스레드의 `Thread` 객체에서 호출
	- 이런 객체는 `spawn`으로 리턴되는 **join handle**로부터 얻거나, thread 스스로가 `std::thread::current()`를 사용하여 얻을 수 있음

#### 두 스레드에서 뮤텍스를 사용해 큐 하나를 공유하는 예시
- 메인 스레드: 큐에 매 초마다 아이템 추가
- 새로운 스레드: 큐의 아이템을 가져감
- 스레드 파킹: 큐가 비었을 때 스레드가 기다리도록 하기 위해 사용
```rust
use std::time::Duration;
use std::collections::VecDeque;
fn main() {
	let queue = Mutex::new(VecDeque::new());
	thread::scope(|s| {
		// consumer thread
		let t = s.spawn(|| loop {
			let item = queue.lock().unwrap().pop_front();
			if let Some(item) == item {
			dbg!(item);
			} else {
				thread::park();
			}
		});
		// producer thread
		fn i in 0.. {
			queue.lock().unwrap().push_back(i);
			t.thread().unpark();
			thread::sleep(Duration::from_secs(1));
		}
	})
}
```
- consumer thread
	- 무한 루프 안에서 큐의 아이템을 하나 빼서 `dbg` 매크로를 이용해 값 출력
	- 큐가 비었다면 스레드는 작동을 멈추고 `park()` 함수를 사용하여 잠자기에 들어감
	- 만약 파킹 상태가 해제되면 `park()` 함수 호출이 리턴되고, 다시 큐가 빌때까지 `loop` 반복
- producer thread
	- 매 초마다 새로운 숫자를 만들어 queue에 넣음
	- 큐에 아이템을 추가할 때마다 `unpark()`메서드를 consumer thread에 사용해 parking 해제
	- 이후 consumer thread에서 대기 상태 해제 및 다음 원소 처리 가능
- 위 프로그램이 이론적으로는 이슈가 없으나
	- 파킹을 코드에서 삭제하면 매우 **비효율적**으로 작동
- `park()` 함수를 리턴하는 경우는 `unpark()`외에도 존재함
	- 매우 드물게 스레드를 **속여서 깨우는 상황**(spurious wake-up)
- 위 예시에서는 이 문제가 발생하지는 않음
	- 소비자 스레드, 큐를 잠금상태로 만들고 큐가 비었다면 즉시 잠금을 해제한 다음
	- 스스로 파킹상태가 되기 때문

#### 스레드 파킹의 중요한 특징
- 스레드가 파킹되기전 `unpark()`을 사용해도, 이 요청이 사라지지 않고 유지됨
- 파킹 해제 요청은 어딘가 잘 기록됨
- 스레드가 파킹 되려고하는 순간,
	- 해당 요청을 기억해서 잠자기 상태로 진입하지 x
	- 작업을 계속함
- 시나리오
	1. 소비자 스레드(C)가 큐를 잠금
	2. C가 큐에서 아이템 꺼내려고 시도, 큐가 비어있어 None 리턴
	3. C가 큐의 잠금 해제
	4. 생산자 스레드(P)가 큐를 잠금
	5. P가 새로운 아이템 추가
	6. P가 큐의 잠금 해제
	7. P가 `unpark()` 호출, C에게 새로운 아이템이 있음을 알림
	8. C는 `park()`을 호출하여 더 많은 아이템을 기다리기 위해 잠자기 돌입
- 위 시나리오에서 3~8 시점 사이에
	- 스레드가 파킹되기 전 
	- 4~7이 수행될 수 있음
- 만약 스레드가 파킹되지 않은 상태에서, `unpark()`이 아무일도 하지 않으면
	- 파킹 해제 요청은 사라질 것
	- 소비자 스레드는 큐에 값이 있음에도 여전히 기다리는 상태
	- 파킹 해제 요청이 저장되었다가 `park()`가 호출될 때 사용되므로, 이런 문제는 걱정 x
- 하지만 파킹 해제 요청이 여러개로 쌓이지는 않음
	- `unpark()` 2회, `park()` 2회 -> 스레드는 여전히 잠자기 상태
	- 첫번째 `park()` 호출이 파킹 해제 요청을 받자마자 함수 종료
	- 두번째 `park()`는 평소와 같이 잠자기
- 위의 예제에서 중요한 부분
	- 모든 아이템이 처리된 후 스레드를 파킹하는 것 x
	- 큐가 비어있는 것으로 확인한 경우에만 스레드 파킹
	- **여러번의 `unpark()`호출이 하나의 `park()`호출만 종료시킬 수 있음**
- 만약 `park()` 함수가 종료된 시점과
	- 큐가 잠금상태가 되고 비워진 시점 중간에
	- `unpark()`가 호출된다면 사실 `unpark()`을 호출할 필요는 x
	- 하지만 `unpark()`은 다음 `park()`호출이 즉시 종료되게끔 함
	- 이로 인해 (비어 있는)큐가 잠금 상태가 되었다가 해제되는데 추가 시간 소요
	- 프로그램 결과는 정확하겠으나, 효율성과 성능 측면에 문제 발생
- 이 매커니즘은 예시와 같이 간단한 경우에는 잘 동작
	- 복잡한 상황에서는 동작하지 x
- e.g. 여러개의 소비자 스레드가 하나의 큐로부터 아이템을 가져갈 때
	- 생산자 스레드는 어떤 스레드가 기다리는지 알 수 없음
	- 어떤 스레드를 깨워야할지도 모름
	- 그에 따라, 생산자 스레드는 어떤 스레드가 대기중이고, 어떤 조건이 만족되기를 기다리고 있는지 알아야 함
