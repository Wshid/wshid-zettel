---
date: 2024-05-01
datetime: 2024-05-01T09:01:00
book: 러스트_동시성_프로그래밍
page:
  - "32"
tags: 
references: 
aliases:
---
러스트에서 값을 대여할 수 있는 방법

## 불변 대여(immutable borrowing)
- `&`를 사용하여 값을 빌릴 때 `immutable reference`가 됨
	- 복사할 수 있는 레퍼런스
- 어떤 레퍼런스가 참조하고 있는 값은, 이 레퍼런스를 복사한 모든 레퍼런스가 함께 공유
- 값을 변경하는 것을 허용하지 않음

## 가변 대여(mutable borrowing)
- `&mut` 키워드 사용시 `mutable reference`가 만들어짐
- 현재의 가변 레퍼런스가 유일하게 이 값을 가변으로 대여
- 가변 레퍼런스로 값을 바꾸면, 코드의 다른 부분에서 값이 변경되는 것을 막을 수 있음

불변대여와 가변대여를 통해 **[[data_race|데이터 경합]]**이 일어나는 것을 막을 수 있음

컴파일러가 소유권 대여 규칙을 통해 데이터 경합이 발생하지 않을 것이라고 가정하는 이유?
```rust
fn f(a: &i32, b: &mut i32) {
	let before = *a;
	*b += 1;
	let after = *a;
	if before != after {
		x(); // 절대 실행되지 않음
	}
}
```
- 정수 값에 대한 불변 레퍼런스 a를 입력 받아
	- b가 참조하는 값을 증가
- before와 after에 값을 저장
- 컴파일러는 **소유권 대여 규칙**과 **데이터 경합**에 대한 가정을 바탕으로
	- **a와 b가 같은 값을 참조하고 있다고 생각하지 x**
- a가 소유권을 대여하고 있는 중에는, 프로그램 전체 코드 어디에서도
	- 원래 값을 **가변 레퍼런스**로 대여할 수 없음
- 따라서 컴파일러는 `*a`가 절대 값이 변한다고 생각하지 않기 때문에, `if`조건은 절대 참이 될 수 없음
- 컴파일 과정에서 프로그램 최적화를 위해 `if`문 전체를 제거할 수 있음
- 소유권 대여 규칙과 데이터 경합에 대한 컴파일러 가정을 깨는 러스트 코드를 작성하는 유일한 방법?
	- `unsafe`를 사용하여 컴파일러의 안전 검사 일부를 비활성화

## 정의되지 않은 동작
- C, C++, Rust 같은 언어는 **정의되지 않은 동작**(undefined behavior)를 피하기 위한 규칙을 가지고 있음
	- e.g. Rust, 객체에 한 개 이상의 가변 레퍼런스를 만들 수 없음
- Rust에서 이런 규칙을 무시하려면 `unsafe` 키워드 사용
	- 코드가 잘못되었거나, 사용하기 위험하다 -> X
	- 컴파일러가 코드가 안전한지 검사하지 X
- 컴파일러 규칙을 위반하는 코드 -> unsound(불건전)하다고 함
- 컴파일러는 코드를 들여다보지 않고도, 규칙은 항상 지켜진다고 생각함
	- 규칙이 깨진다면, 이 상황이 **정의되지 않은 동작**이 되며, 무조건 막아야 함
- 컴파일러가 이런 규칙을 지키지 않으면, 코드의 여러부분에서 잘못된 결과 발생

#### get_unchecked
```rust
let a = [123, 456, 789];
let b = unsafe { a.get_unchecked(index) };
```
- `get_unchecked` 메서드
	- 주어진 인덱스를 사용하여, 슬라이스의 원소 1개를 가져옴
	- `a[index]`를 사용하면, 컴파일러가 인덱스 범위를 벗어났는지를 확인하지만,
	- `get_unchecked` 메서드 사용시, 컴파일러가 확인하지 X
- a의 길이가 3이므로, compiler는 index가 3보다 작은 값이라고 가정함
	- 단, 위 상황에서는 index에 따라 컴파일러의 가정이 맞을수도 틀릴수도 있음
- `index`가 3 이상이라면, 이 가정이 깨짐
	- 슬라이스의 메모리 범위보다 1바이트 뒤를 읽으며, 아무 값이나 읽음
	- 프로그램의 예상치 못한 종료
	- 의도하지 않는 결과 수행
- 또한, 정의되지 않은 동작은 그 이전의 코드에 문제를 일으킬 수도 있음

#### 이전의 코드의 문제를 발생시키는 경우
```rust
match index {
	0 => x(),
	1 => y(),
	_ => z(index),
}

let a = [123, 456, 789];
let b = unsafe { a.get_unchecked(index) };
```
- `unsafe`코드 때문에, compiler는 index가 0,1,2 중에 하나라고 생각
	- match에서 마지막 경우는 index가 2가 된다고 생각해서, match의 결과는 z(2)가 됨
- 컴파일러가 match문을 최적화 할때 사용하는 방법은 `z`를 최적화 할때도 사용 가능
	- z(index)가 항상 z(2)로 사용된다면, 필요 없는 코드를 컴파일 과정에서 버릴 수 있음
- 만약 `index=3`으로 수행하게 되면, match 구문에서 `z(3)`을 수행하려고 할 것
	- 마지막 `unsafe`줄에 도달하기 전에 예상치 못한 문제 발생
- 정의되지 않은 동작은 예상치 못한 방법으로
	- 프로그램 진행 방향 또는 반대 방향으로 전파 가능
- `unsafe`함수를 호출시,
	- 함수의 문서를 주의 깊게 읽고,
	- 정의되지 않은 동작을 피하기 위해 지켜야할 안전 요구 사항(safety requirement)를 이해하는 것이 중요