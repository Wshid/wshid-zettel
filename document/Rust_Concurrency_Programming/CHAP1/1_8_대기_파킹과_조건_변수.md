---
date: 2024-06-26
datetime: 2024-06-26 21:32:26
book: 러스트_동시성_프로그래밍
page:
  - "48"
tags: 
references: 
aliases:
---
- 데이터가 여러 스레드에 의해 값이 변경된다면
	- 스레드는 어떤 이벤트가 발생하거나, 데이터에 대한 특정 조건이 만족되기를 기다림
- e.g. 비어있는 Vec을 보호하는 [[Mutex]]가 있을 때,
	- 이 벡터가 어떤 값이든 담고 있기를 기다릴 수 있음
- [[Mutex]]는 여러 스레드가 뮤텍스의 잠금이 해제되기를 기다리는 것을 허용함
	- 하지만 다른 조건을 만족하는 걸 기다리도록 하는 기능은 제공 x
- 뮤텍스가 여러 스레드에서 값을 접근하고 변경하도록 하는 유일한 방법이라면,
	- 조건이 만족되는지 검사하기 위해 계속해서 뮤텍스를 잠금 상태로 변경, Vec에 어떤 값이 있는지 계획 확인 필요함
- [[Mutex]]는 잠금이 해제될 때까지 스레드가 대기할 수 있게 해주지만, 다른 조건을 기다리는 기능은 제공하지 않음
- 뮤텍스가 전부라면, 뮤텍스를 계속 잠그고 `Vec`에 아직 아무것도 없는지 반복해서 확인 필요

# 1.8.1. 스레드 파킹
- 다른 스레드의 알림을 기다리는 방법 중 하나
- 스레드 파킹 상태에서는 CPU 사이클을 소모하지 않음
- 스레드는 스스로를 park할 수 있으며, 다른 스레드가 파킹된 스레드를 unpark 할 수 있음
- `std::thread::park()`을 사용하여 스레드 파킹 가능
	- `unpark()`을 파킹 해제하기 원하는 스레드의 `Thread` 객체에서 호출
	- 이런 객체는 `spawn`으로 리턴되는 **join handle**로부터 얻거나, thread 스스로가 `std::thread::current()`를 사용하여 얻을 수 있음

## 두 스레드에서 뮤텍스를 사용해 큐 하나를 공유하는 예시
- 메인 스레드: 큐에 매 초마다 아이템 추가
- 새로운 스레드: 큐의 아이템을 가져감
- 스레드 파킹: 큐가 비었을 때 스레드가 기다리도록 하기 위해 사용
```rust
use std::time::Duration;
use std::collections::VecDeque;
fn main() {
	let queue = Mutex::new(VecDeque::new());
	thread::scope(|s| {
		// consumer thread
		let t = s.spawn(|| loop {
			let item = queue.lock().unwrap().pop_front();
			if let Some(item) == item {
			dbg!(item);
			} else {
				thread::park();
			}
		});
		// producer thread
		fn i in 0.. {
			queue.lock().unwrap().push_back(i);
			t.thread().unpark();
			thread::sleep(Duration::from_secs(1));
		}
	})
}
```
- consumer thread
	- 무한 루프 안에서 큐의 아이템을 하나 빼서 `dbg` 매크로를 이용해 값 출력
	- 큐가 비었다면 스레드는 작동을 멈추고 `park()` 함수를 사용하여 잠자기에 들어감
	- 만약 파킹 상태가 해제되면 `park()` 함수 호출이 리턴되고, 다시 큐가 빌때까지 `loop` 반복
- producer thread
	- 매 초마다 새로운 숫자를 만들어 queue에 넣음
	- 큐에 아이템을 추가할 때마다 `unpark()`메서드를 consumer thread에 사용해 parking 해제
	- 이후 consumer thread에서 대기 상태 해제 및 다음 원소 처리 가능
- 위 프로그램이 이론적으로는 이슈가 없으나
	- 파킹을 코드에서 삭제하면 매우 **비효율적**으로 작동
- `park()` 함수를 리턴하는 경우는 `unpark()`외에도 존재함
	- 매우 드물게 스레드를 **속여서 깨우는 상황**(spurious wake-up)
- 위 예시에서는 이 문제가 발생하지는 않음
	- 소비자 스레드, 큐를 잠금상태로 만들고 큐가 비었다면 즉시 잠금을 해제한 다음
	- 스스로 파킹상태가 되기 때문

## 스레드 파킹의 중요한 특징
- 스레드가 파킹되기전 `unpark()`을 사용해도, 이 요청이 사라지지 않고 유지됨
- 파킹 해제 요청은 어딘가 잘 기록됨
- 스레드가 파킹 되려고하는 순간,
	- 해당 요청을 기억해서 잠자기 상태로 진입하지 x
	- 작업을 계속함
- 시나리오
	1. 소비자 스레드(C)가 큐를 잠금
	2. C가 큐에서 아이템 꺼내려고 시도, 큐가 비어있어 None 리턴
	3. C가 큐의 잠금 해제
	4. 생산자 스레드(P)가 큐를 잠금
	5. P가 새로운 아이템 추가
	6. P가 큐의 잠금 해제
	7. P가 `unpark()` 호출, C에게 새로운 아이템이 있음을 알림
	8. C는 `park()`을 호출하여 더 많은 아이템을 기다리기 위해 잠자기 돌입
- 위 시나리오에서 3~8 시점 사이에
	- 스레드가 파킹되기 전 
	- 4~7이 수행될 수 있음
- 만약 스레드가 파킹되지 않은 상태에서, `unpark()`이 아무일도 하지 않으면
	- 파킹 해제 요청은 사라질 것
	- 소비자 스레드는 큐에 값이 있음에도 여전히 기다리는 상태
	- 파킹 해제 요청이 저장되었다가 `park()`가 호출될 때 사용되므로, 이런 문제는 걱정 x
- 하지만 파킹 해제 요청이 여러개로 쌓이지는 않음
	- `unpark()` 2회, `park()` 2회 -> 스레드는 여전히 잠자기 상태
	- 첫번째 `park()` 호출이 파킹 해제 요청을 받자마자 함수 종료
	- 두번째 `park()`는 평소와 같이 잠자기
- 위의 예제에서 중요한 부분
	- 모든 아이템이 처리된 후 스레드를 파킹하는 것 x
	- 큐가 비어있는 것으로 확인한 경우에만 스레드 파킹
	- **여러번의 `unpark()`호출이 하나의 `park()`호출만 종료시킬 수 있음**
- 만약 `park()` 함수가 종료된 시점과
	- 큐가 잠금상태가 되고 비워진 시점 중간에
	- `unpark()`가 호출된다면 사실 `unpark()`을 호출할 필요는 x
	- 하지만 `unpark()`은 다음 `park()`호출이 즉시 종료되게끔 함
	- 이로 인해 (비어 있는)큐가 잠금 상태가 되었다가 해제되는데 추가 시간 소요
	- 프로그램 결과는 정확하겠으나, 효율성과 성능 측면에 문제 발생
- 이 매커니즘은 예시와 같이 간단한 경우에는 잘 동작
	- 복잡한 상황에서는 동작하지 x
- e.g. 여러개의 소비자 스레드가 하나의 큐로부터 아이템을 가져갈 때
	- 생산자 스레드는 어떤 스레드가 기다리는지 알 수 없음
	- 어떤 스레드를 깨워야할지도 모름
	- 그에 따라, 생산자 스레드는 어떤 스레드가 대기중이고, 어떤 조건이 만족되기를 기다리고 있는지 알아야 함

# 1.8.2. 조건 변수
- `condition variable`
- 뮤텍스에 의해 보호되는 데이터에 어떤 일이 발생할때까지 기다리는데 일반적으로 사용하는 방법
- 두개의 메서드
	- wait(대기)
	- notify(알림): 대기 하고 있던 스레드를 깨움
- 여러 개의 스레드는 **하나의 조건 변수**를 기다릴 수 있음
- 하나의 대기 스레드만 깨우기 가능
	- `notify_one` method
- 여러 스레드 깨우기 가능
	- `notify_all` method
- 특정한 이벤트, 혹은 관심이 있는 이벤트를 위해 생성 가능
	- e.g. 비어있는 큐에 값이 들어오기를 기다리는 이벤트를 위해 조건 변수 생성
- 이벤트 발생 or 조건 만족 스레드는
	- 조건변수를 기다리고 있는 스레드에 대해 알지 못하는 상태로
	- 조건 변수에 해당 내용을 알림
- [[Mutex|뮤텍스]]를 잠금 해제하고 조건 변수를 기다리는 동안 알림을 놓칠 수 있을 수도?
	- 이를 막기 위해 조건 변수는 **아토믹**하게 뮤텍스를 잠금 해제 후 대기
	- 알림은 놓칠 수가 없음
- `std::sync::Condvar`
- `wait`메서드는 뮤텍스가 잠김 상태임을 정확히 알기 위해 [[MutexGuard]]를 입력으로 받음
	- 조건 변수는 뮤텍스를 잠금 해제하고 스레드를 잠자기 상태로 만듦
	- 스레드가 깨어나면 뮤텍스를 다시 잠금 후, 뮤텍스가 다시 잠금 상태인지 검증하기 위해 새로운 [[MutexGuard]]를 리턴함

## Condvar 예시
```rust
use std::time::Duration;
use std::sync::Condvar;

fn main() {
	let queue = Mutex::new(VecDeque::new());
	let not_empty = Condvar::new();
	thread::scope(|s| {
		s.spawn(|| loop {
			// lock: 뮤텍스를 잠그는 메서드, 잠금 성공시 MutexGuard 리턴
			// unwrap: Result(작업 성공 여부, Ok), Option(값 존재 여부, Some)
			let mut q = queue.lock().unwrap();
			let item = loop {
				if let Some(item) = q.pop_front() {
					break item;
				} else {
					q = not_empty.wait(q).unwrap();
				}
			};
			drop(q);
			dbg!(item);
		});
		for i in 0.. {
			queue.lock().unwrap().push_back(i);
			not_empty.notify_one();
			thread::sleep(Duration::from_secs(1));
		}
	});
}
```
- 큐를 포함하는 `Mutex`뿐 아니라, '비어있지 않음' 조건을 전달하기 위한 `Condvar` 존재
- 더 이상 어떤 스레드를 깨울지 알 필요가 없음
	- spawn의 리턴값 존재 x
	- `notify_one` 메서드로 대기하는 스레드를 깨움
- 잠금 해제, 대기, 다시 잠그기는 모두 `wait`메서드를 통해 이루어짐
	- 가드를 `wait` 메서드에 전달하면서도
	- 아이템을 처리하기 전에 가드를 drop 할 수 있도록 제어 흐름을 재구성

- 이제 아무것도 변경하지 않고도, 원하는 만큼의 소비자 스레드를 생성하고
	- 나중에 더 많이 생성도 가능함
- 조건변수는 **관심 있는 스레드**에게 알림을 전달하는 역할
- 서로 다른 조건에 관심이 있는 스레드가 존재하는 복잡한 시스템일 경우
	- 각 조건에 대해 `Condvar`를 정의할 수 있음
	- e.g. 대기열이 비어있지 않음을 나타내기 위한 정의
		- 대기열이 비어있음을 나타내기 위한 정의
		- 각 스레드는 자신이 수행중인 작업에 맞게 알람 발생 대기
- `Condvar`는 **단일 뮤텍스**에서만 사용됨
	- 두 개의 스레드가 서로 다른 뮤텍스를 사용하여, 동시에 조건 변수 대기시 [[panic]]이 발생할 수 있음
- `Condvar`의 단점은 `Mutex`와 함께 사용할때만 작동
	- 대부분의 경우 **데이터를 보호하기 위해** 이미 뮤텍스를 사용하기 때문에 큰 문제는 아님
- `thread::park()`와 `Condvar::wait()`의 시간 제한 변형인
	- `thread::park_timeout()`, `Condvar::wait_timeout()`이 존재
	- 이 함수는 알림이 기다리는 것을 포기하고, 깨어나야하는 시간인 `Duration`을 추가 인수로 받음


# 1장 요점 정리
- 동일한 프로그램 내에서 여러 스레드 동시 수행 및 생성 가능
- 메인 스레드가 종료되면 전체 프로그램 종료
- 데이터 경합: 정의되지 않은 동작
	- 러스트의 타입 시스템에 의해 (unsafe가 아닐경우) 완전히 방지 가능
- [[Send]] [[rust_trait|trait]]을 구현하는 데이터는 다른 스레드로 **전송** 가능
- [[Sync]] trait을 구현하는 데이터는 다른 스레드간 **공유 가능**
- 일반 스레드의 라이프타임은 **프로그램의 실행 시간**과 같음
	- `static` 라이프타임의 데이터 또는 누수된 할당(leaked allocation)만 **소유권 대여**가 가능
- [[rust_arc|Arc]](레퍼런스 카운팅)을 사용하면 **소유권 공유**
	- 적어도 하나의 스레드가 데이터를 사용하는 한
	- 데이터가 지속되게 할 수 있음
- **범위 제한 스레드**는 스레드의 라이프타임을 제한해
	- 로컬변수와 같은 'static 라이프타임이 아닌 데이터'를 대여할 수 있도록 하는데 유용
- [[reference_&T|&T]]는 공유 레퍼런스이고 [[독점 레퍼런스|&mut]]는 독점 레퍼런스
	- 일반 타입은 [[reference_&T|공유 레퍼런스]]를 통한 값의 변경을 허용하지 않음
- 일부 타입은 [[UnsafeCell]] 덕분에 **내부 가변성**을 가지고 있어,
	- [[reference_&T|공유 레퍼런스]]를 통한 값의 변경이 가능함
- 단일 스레드에서 내부 가변성을 위한 표준타입은 [[Cell]]과 [[RefCell]]
	- [[Atomic]], [[Mutex]], [[RwLock]]은 멀티스레드에 해당
- [[Cell]]과 아토믹 타입들은 **전체 값**만 교체할 수 있는 반면
	- [[RefCell]], [[Mutex]], [[RwLock]]은 접근 규칙을 **동적**으로 적용하여 값을 직접 변경할 수 있음
- [[#1.8.1. 스레드 파킹|스레드 파킹]]은 스레드가 특정 조건을 기다리는데 편리한 방법
- 스레드가 기다리는 조건이 [[Mutex]]로 보호되는 데이터와 관련되었다면 [[#1.8.2. 조건 변수|Condvar]]를 사용하는 것이 [[#1.8.1. 스레드 파킹|스레드 파킹]]보다 편리하고 효율적